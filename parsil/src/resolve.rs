//! This module converts a user-defined query into one that can directly be
//! executed on the ryhope table containing the related data. The main steps
//! are:
//!
//! 1. convert virtual columns accesses into JSON payload access;
//!
//! 2. wrap the original query into a CTE to expand CoW row spans into
//! individual column for each covered block number.
use anyhow::*;
use log::warn;
use sqlparser::ast::{Expr, Ident, Query, Select, TableFactor};
use std::collections::HashSet;

use crate::{
    symbols::{RootContextProvider, TableSymbols},
    visitor::{AstPass, Visit},
};

/// The context created at each `SELECT`
struct Context(Vec<TableSymbols>);

/// An ordered list of tables created from the successively `FROM` clauses of a
/// query, forming the symbol table for the `SELECT` body at the same level.
struct Resolver<C: RootContextProvider> {
    /// The current stack of symbols available. A new context is introduced in
    /// each `SELECT` statement and make available to its descendants.
    contexts: Vec<Context>,
    context: C,
}
impl<C: RootContextProvider> Resolver<C> {
    /// Create a new empty [`TableStack`]
    fn new(context: C) -> Self {
        Resolver {
            contexts: Vec::new(),
            context,
        }
    }

    /// Takes a symbol addressing a column in a virtual table and convert it
    /// into a JSONB access into the actual table.
    fn resolve(&self, symbol: &Ident) -> Result<Option<Expr>> {
        let candidates = self
            .contexts
            .last()
            .unwrap()
            .0
            .iter()
            .filter_map(|t| t.resolve(&symbol.value))
            .collect::<HashSet<_>>(); // The same table may appear at multiple level, so deduplicate
        ensure!(!candidates.is_empty(), "column `{symbol}` does not exist");
        ensure!(candidates.len() <= 1, "column `{symbol}` is ambiguous");

        Ok(candidates
            .into_iter()
            .next()
            .map(|(table, column)| Expr::BinaryOp {
                left: Box::new(Expr::CompoundIdentifier(
                    [Ident::new(table), Ident::new("payload")].to_vec(),
                )),
                op: sqlparser::ast::BinaryOperator::Arrow,
                right: Box::new(Expr::Identifier(Ident::new(column))),
            }))
    }

    /// Takes a symbol addressing a fully qualified column in a virtual table
    /// and convert it into a JSONB access into the actual table.
    fn resolve_compound(&self, compound: &[Ident]) -> Result<Option<Expr>> {
        ensure!(
            compound.len() == 2,
            "`{compound:?}`: deeply coumpounded symbols are not supported"
        );
        let candidates = self
            .contexts
            .iter()
            .flat_map(|tables| {
                tables
                    .0
                    .iter()
                    .filter_map(|t| t.resolve_qualified(&compound[0].value, &compound[1].value))
            })
            .collect::<HashSet<_>>(); // The same table may appear at multiple level, so deduplicate
        ensure!(candidates.len() <= 1, "column `{compound:?}` is ambiguous");

        Ok(candidates
            .into_iter()
            .next()
            .map(|(table, column)| Expr::BinaryOp {
                left: Box::new(Expr::CompoundIdentifier(
                    [Ident::new(table), Ident::new("payload")].to_vec(),
                )),
                op: sqlparser::ast::BinaryOperator::Arrow,
                right: Box::new(Expr::Identifier(Ident::new(column))),
            }))
    }

    /// Create the new context generated by a SELECT ... FROM ... [JOIN ...].
    /// This context may contain from one (in the case of a simple select) to
    /// many (in the case of chained joins) tables and their symbols.
    fn enter_context<'a, I: Iterator<Item = &'a TableFactor>>(&mut self, tables: I) -> Result<()> {
        self.contexts.push(Context(Vec::new()));
        for table in tables {
            match table {
                TableFactor::Table {
                    name, alias, args, ..
                } => {
                    if args.is_some() {
                        warn!("ignoring tablue-valued function {name}");
                    } else {
                        ensure!(
                            name.0.len() == 1,
                            "compounded table names unsupported: `{}`",
                            name
                        );
                        let real_name = &name.0[0].value;
                        let columns = self
                            .context
                            .fetch_table(&real_name)?
                            .columns
                            .into_iter()
                            .map(|c| c.name)
                            .collect::<HashSet<_>>();
                        self.contexts
                            .last_mut()
                            .unwrap()
                            .0
                            .push(if let Some(alias) = alias {
                                TableSymbols::Alias {
                                    alias_name: alias.name.value.to_owned(),
                                    real_name: real_name.to_owned(),
                                    columns,
                                }
                            } else {
                                TableSymbols::Normal(real_name.to_owned(), columns)
                            });
                    }
                }
                TableFactor::Derived { .. }
                | TableFactor::TableFunction { .. }
                | TableFactor::Function { .. }
                | TableFactor::UNNEST { .. }
                | TableFactor::JsonTable { .. }
                | TableFactor::NestedJoin {
                    table_with_joins: _,
                    alias: _,
                } => todo!(),
                TableFactor::Pivot { .. }
                | TableFactor::Unpivot { .. }
                | TableFactor::MatchRecognize { .. } => {}
            }
        }
        Ok(())
    }

    fn exit_context(&mut self) {
        self.contexts.pop();
    }
}

impl<C: RootContextProvider> AstPass for Resolver<C> {
    fn post_expr(&mut self, e: &mut Expr) -> Result<()> {
        match e {
            Expr::Identifier(symbol) => {
                if let Some(new_e) = self.resolve(symbol)? {
                    *e = new_e;
                }
            }
            Expr::CompoundIdentifier(compound) => {
                if let Some(new_e) = self.resolve_compound(compound)? {
                    *e = new_e;
                }
            }
            Expr::Wildcard => {}
            Expr::QualifiedWildcard(_) => bail!("unsupported"),
            _ => {}
        }
        Ok(())
    }

    fn pre_select(&mut self, select: &mut Select) -> Result<()> {
        self.enter_context(
            select.from.iter().flat_map(|t| {
                std::iter::once(&t.relation).chain(t.joins.iter().map(|j| &j.relation))
            }),
        )
    }

    fn post_select(&mut self, _: &mut Select) -> Result<()> {
        self.exit_context();
        Ok(())
    }
}

pub fn resolve<C: RootContextProvider>(q: &Query, context: C) -> Result<()> {
    let mut converted_query = q.clone();
    let mut resolver = Resolver::new(context);
    converted_query.visit(&mut resolver)?;
    println!("Original query:\n>> {}", q);
    println!("Translated query:\n>> {}", converted_query);
    Ok(())
}
