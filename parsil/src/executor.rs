use anyhow::*;
use log::*;
use sqlparser::ast::{
    BinaryOperator, CastKind, DataType, ExactNumberInfo, Expr, Function, FunctionArg,
    FunctionArgExpr, FunctionArgumentList, FunctionArguments, GroupByExpr, Ident, ObjectName,
    Query, Select, SelectItem, SetExpr, TableAlias, TableFactor, TableWithJoins, Value,
    WildcardAdditionalOptions,
};

use crate::{
    symbols::{ColumnKind, ContextProvider},
    visitor::{AstPass, Visit},
};

/// Generate an [`Expr`] encoding `generate_series(__valid_from, __valid_until)`
fn expand_block_range() -> Expr {
    Expr::Function(Function {
        name: ObjectName(vec![Ident::new("generate_series")]),
        parameters: FunctionArguments::None,
        args: FunctionArguments::List(FunctionArgumentList {
            duplicate_treatment: None,
            args: vec![
                FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Identifier(Ident::new(
                    "__valid_from",
                )))),
                FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Identifier(Ident::new(
                    "__valid_until",
                )))),
            ],
            clauses: vec![],
        }),
        filter: None,
        null_treatment: None,
        over: None,
        within_group: vec![],
    })
}

/// The SQL datatype to represent a UINT256
const UINT256: DataType = DataType::Numeric(ExactNumberInfo::None);

/// Generate an [`Expr`] encoding for `payload -> cells -> '{id}' -> value
fn fetch_from_payload(id: u64) -> Expr {
    Expr::Cast {
        kind: CastKind::DoubleColon,
        expr: Box::new(Expr::Nested(Box::new(Expr::BinaryOp {
            left: Box::new(Expr::Identifier(Ident::new("payload"))),
            op: BinaryOperator::Arrow,
            right: Box::new(Expr::BinaryOp {
                left: Box::new(Expr::Value(Value::SingleQuotedString("cells".into()))),
                op: BinaryOperator::Arrow,
                right: Box::new(Expr::BinaryOp {
                    left: Box::new(Expr::Value(Value::SingleQuotedString(id.to_string()))),
                    op: BinaryOperator::LongArrow,
                    right: Box::new(Expr::Value(Value::SingleQuotedString("value".into()))),
                }),
            }),
        }))),
        data_type: UINT256,
        format: None,
    }
}

/// The `RowFetcher` gathers all `(primary_index, row_key)` pairs generated by a
/// query, used then to generate the values public inputs for the query
/// circuits.
struct RowFetcher<'a, C: ContextProvider> {
    context: &'a C,
}
impl<'a, C: ContextProvider> RowFetcher<'a, C> {
    fn new(context: &'a C) -> Self {
        Self { context }
    }

    fn process(&mut self, query: &mut Query) -> Result<()> {
        query.visit(self)?;

        if let SetExpr::Select(ref mut select) = *query.body {
            select.projection = vec![
                SelectItem::UnnamedExpr(Expr::Identifier(Ident::new("key"))),
                SelectItem::UnnamedExpr(Expr::Identifier(Ident::new("block"))),
            ];
        }

        Ok(())
    }
}
impl<'a, C: ContextProvider> AstPass for RowFetcher<'a, C> {
    fn post_select(&mut self, select: &mut Select) -> Result<()> {
        // When we meet a SELECT, insert a * to be sure to bubble up the key &
        // block number
        select
            .projection
            .push(SelectItem::Wildcard(WildcardAdditionalOptions {
                opt_ilike: None,
                opt_exclude: None,
                opt_except: None,
                opt_replace: None,
                opt_rename: None,
            }));
        Ok(())
    }

    fn post_table_factor(&mut self, table_factor: &mut TableFactor) -> Result<()> {
        if let Some(replacement) = match table_factor {
            TableFactor::Table { name, alias, .. } => {
                // The actual table being referenced
                let concrete_table_name = &name.0[0].value;

                // Fetch all the column declared in this table
                let table = self.context.fetch_table(&concrete_table_name)?;
                let table_columns = &table.columns;

                // Extract the apparent table name (either the concrete one
                // or its alia), and, if they exist, the aliased column
                // names.
                let (apparent_table_name, column_aliases) = if let Some(table_alias) = alias {
                    (
                        table_alias.name.value.to_owned(),
                        if table_alias.columns.is_empty() {
                            None
                        } else {
                            Some(table_alias.columns.clone())
                        },
                    )
                } else {
                    (concrete_table_name.to_owned(), None)
                };

                let select_items =
                    // Insert the `key` column in the selected values...
                    std::iter::once(SelectItem::UnnamedExpr(Expr::Identifier(Ident::new("key"))))
                    .chain(std::iter::once(
                        SelectItem::ExprWithAlias { expr: expand_block_range(), alias: Ident::new("block") }
                    ))
                    // then continue normally
                        .chain(table_columns.iter().enumerate().map(|(i, column)| {
                            let alias = Ident::new(
                                column_aliases
                                    .as_ref()
                                    .map(|a| a[i].value.as_str())
                                    .unwrap_or(column.name.as_str()),
                            );
                            match column.kind {
                                // primary index column := generate_series(__valid_from, __valid_until) AS name
                                ColumnKind::PrimaryIndex => SelectItem::ExprWithAlias {
                                    expr: expand_block_range(),
                                    alias,
                                },
                                // other columns := payload->'cells'->'id'->'value' AS name
                                ColumnKind::SecondaryIndex | ColumnKind::Standard => {
                                    SelectItem::ExprWithAlias {
                                        expr: fetch_from_payload(column.id),
                                        alias,
                                    }
                                }
                            }
                        }))
                        .collect();

                Some(TableFactor::Derived {
                    lateral: false,
                    subquery: Box::new(Query {
                        with: None,
                        body: Box::new(SetExpr::Select(Box::new(Select {
                            distinct: None,
                            top: None,
                            projection: select_items,
                            into: None,
                            from: vec![TableWithJoins {
                                relation: TableFactor::Table {
                                    name: ObjectName(vec![Ident::new(concrete_table_name)]),
                                    alias: None,
                                    args: None,
                                    with_hints: vec![],
                                    version: None,
                                    with_ordinality: false,
                                    partitions: vec![],
                                },
                                joins: vec![],
                            }],
                            lateral_views: vec![],
                            prewhere: None,
                            selection: None,
                            group_by: GroupByExpr::Expressions(vec![], vec![]),
                            cluster_by: vec![],
                            distribute_by: vec![],
                            sort_by: vec![],
                            having: None,
                            named_window: vec![],
                            qualify: None,
                            window_before_qualify: false,
                            value_table_mode: None,
                            connect_by: None,
                        }))),
                        order_by: None,
                        limit: None,
                        limit_by: vec![],
                        offset: None,
                        fetch: None,
                        locks: vec![],
                        for_clause: None,
                        settings: None,
                        format_clause: None,
                    }),
                    // Subqueries *MUST* have an alias in PgSQL
                    alias: Some(TableAlias {
                        name: Ident::new(apparent_table_name),
                        columns: vec![],
                    }),
                })
            }
            _ => None,
        } {
            *table_factor = replacement;
        }
        Ok(())
    }
}

struct Executor<'a, C: ContextProvider> {
    context: &'a C,
}
impl<'a, C: ContextProvider> Executor<'a, C> {
    fn new(context: &'a C) -> Self {
        Self { context }
    }
}

impl<'a, C: ContextProvider> AstPass for Executor<'a, C> {
    fn post_table_factor(&mut self, table_factor: &mut TableFactor) -> Result<()> {
        if let Some(replacement) = match &table_factor {
            TableFactor::Table {
                name, alias, args, ..
            } => {
                // In this case, we handle
                //
                // ... FROM table [AS alias [(col1, // col2, ...)]]
                //
                // so both the table name and its columns may be aliased.
                if args.is_some() {
                    unreachable!()
                } else {
                    // The actual table being referenced
                    let concrete_table_name = &name.0[0].value;

                    // Fetch all the column declared in this table
                    let table = self.context.fetch_table(&concrete_table_name)?;
                    let table_columns = &table.columns;

                    // Extract the apparent table name (either the concrete one
                    // or its alia), and, if they exist, the aliased column
                    // names.
                    let (apparent_table_name, column_aliases) = if let Some(table_alias) = alias {
                        (
                            table_alias.name.value.to_owned(),
                            if table_alias.columns.is_empty() {
                                None
                            } else {
                                Some(table_alias.columns.clone())
                            },
                        )
                    } else {
                        (concrete_table_name.to_owned(), None)
                    };

                    let select_items = table_columns
                        .iter()
                        .enumerate()
                        .map(|(i, column)| {
                            let alias = Ident::new(
                                column_aliases
                                    .as_ref()
                                    .map(|a| a[i].value.as_str())
                                    .unwrap_or(column.name.as_str()),
                            );
                            match column.kind {
                                // primary index column := generate_series(__valid_from, __valid_until) AS name
                                ColumnKind::PrimaryIndex => SelectItem::ExprWithAlias {
                                    expr: expand_block_range(),
                                    alias,
                                },
                                // other columns := payload->'cells'->'id'->'value' AS name
                                ColumnKind::SecondaryIndex | ColumnKind::Standard => {
                                    SelectItem::ExprWithAlias {
                                        expr: fetch_from_payload(column.id),
                                        alias,
                                    }
                                }
                            }
                        })
                        .collect();

                    Some(TableFactor::Derived {
                        lateral: false,
                        subquery: Box::new(Query {
                            with: None,
                            body: Box::new(SetExpr::Select(Box::new(Select {
                                distinct: None,
                                top: None,
                                projection: select_items,
                                into: None,
                                from: vec![TableWithJoins {
                                    relation: TableFactor::Table {
                                        name: ObjectName(vec![Ident::new(concrete_table_name)]),
                                        alias: None,
                                        args: None,
                                        with_hints: vec![],
                                        version: None,
                                        with_ordinality: false,
                                        partitions: vec![],
                                    },
                                    joins: vec![],
                                }],
                                lateral_views: vec![],
                                prewhere: None,
                                selection: None,
                                group_by: GroupByExpr::Expressions(vec![], vec![]),
                                cluster_by: vec![],
                                distribute_by: vec![],
                                sort_by: vec![],
                                having: None,
                                named_window: vec![],
                                qualify: None,
                                window_before_qualify: false,
                                value_table_mode: None,
                                connect_by: None,
                            }))),
                            order_by: None,
                            limit: None,
                            limit_by: vec![],
                            offset: None,
                            fetch: None,
                            locks: vec![],
                            for_clause: None,
                            settings: None,
                            format_clause: None,
                        }),
                        // Subqueries *MUST* have an alias in PgSQL
                        alias: Some(TableAlias {
                            name: Ident::new(apparent_table_name),
                            columns: vec![],
                        }),
                    })
                }
            }
            TableFactor::Derived { .. } => None,
            TableFactor::TableFunction { .. } => todo!(),
            TableFactor::Function { .. } => todo!(),
            TableFactor::UNNEST { .. } => todo!(),
            TableFactor::JsonTable { .. } => todo!(),
            TableFactor::NestedJoin { .. } => todo!(),
            TableFactor::Pivot { .. } => todo!(),
            TableFactor::Unpivot { .. } => todo!(),
            TableFactor::MatchRecognize { .. } => todo!(),
        } {
            *table_factor = replacement;
        }

        Ok(())
    }
}

pub(crate) fn generate_query_execution<C: ContextProvider>(query: &Query, ctx: C) -> Result<Query> {
    let mut executor = Executor::new(&ctx);
    let mut query_execution = query.clone();
    query_execution.visit(&mut executor)?;
    info!("EXEC: {query_execution}");

    Ok(query_execution)
}

pub(crate) fn generate_query_keys<C: ContextProvider>(query: &Query, ctx: C) -> Result<Query> {
    let mut pis = RowFetcher::new(&ctx);
    let mut query_pis = query.clone();
    pis.process(&mut query_pis)?;
    info!("PIs: {query_pis}");
    Ok(query_pis)
}
