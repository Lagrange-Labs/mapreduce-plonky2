use alloy::primitives::U256;
use anyhow::Result;
use mp2_common::{default_config, proof::ProofWithVK, types::HashOutput, C, D, F};
use plonky2::{field::types::Field, hash::hash_types::HashOut};
use recursion_framework::{
    circuit_builder::{CircuitWithUniversalVerifier, CircuitWithUniversalVerifierBuilder},
    framework::{prepare_recursive_circuit_for_circuit_set as p, RecursiveCircuits},
};
use serde::{Deserialize, Serialize};

use crate::cells_tree::Cell;

use super::{
    full_node::{self, FullNodeCircuit},
    leaf::{self, LeafCircuit},
    partial_node::{self, PartialNodeCircuit},
    secondary_index_cell::SecondaryIndexCell,
    PublicInputs,
};

/// Parameters holding the circuits for the row tree creation
#[derive(Serialize, Deserialize)]
pub struct PublicParameters {
    leaf: CircuitWithUniversalVerifier<F, C, D, 0, leaf::RecursiveLeafWires>,
    full: CircuitWithUniversalVerifier<
        F,
        C,
        D,
        { full_node::NUM_CHILDREN },
        full_node::RecursiveFullWires,
    >,
    partial: CircuitWithUniversalVerifier<
        F,
        C,
        D,
        { partial_node::NUM_CHILDREN },
        partial_node::RecursivePartialWires,
    >,
    row_set: RecursiveCircuits<F, C, D>,
}

const ROW_IO_LEN: usize = super::PublicInputs::<F>::total_len();

impl PublicParameters {
    pub fn build(cells_set: &RecursiveCircuits<F, C, D>) -> Self {
        const ROW_CIRCUIT_SET_SIZE: usize = 3;
        let builder = CircuitWithUniversalVerifierBuilder::<F, D, ROW_IO_LEN>::new::<C>(
            default_config(),
            ROW_CIRCUIT_SET_SIZE,
        );

        let leaf_circuit = builder.build_circuit(cells_set.clone());
        let full_circuit = builder.build_circuit(cells_set.clone());
        let partial_circuit = builder.build_circuit(cells_set.clone());

        let circuits = vec![p(&leaf_circuit), p(&full_circuit), p(&partial_circuit)];
        let circuit_set = RecursiveCircuits::<F, C, D>::new(circuits);
        Self {
            leaf: leaf_circuit,
            full: full_circuit,
            partial: partial_circuit,
            row_set: circuit_set,
        }
    }

    /// returns the set of circuits vk that are generated by this circuit set parameter
    pub fn set_vk(&self) -> &RecursiveCircuits<F, C, D> {
        &self.row_set
    }

    pub fn generate_proof(
        &self,
        input: CircuitInput,
        cells_vk: RecursiveCircuits<F, C, D>,
    ) -> Result<Vec<u8>> {
        match input {
            CircuitInput::Leaf {
                witness,
                cells_proof,
            } => self.generate_leaf_proof(witness, (cells_proof, cells_vk)),
            CircuitInput::Full {
                witness,
                left_proof,
                right_proof,
                cells_proof,
            } => {
                self.generate_full_proof(witness, left_proof, right_proof, (cells_proof, cells_vk))
            }
            CircuitInput::Partial {
                witness,
                child_proof,
                cells_proof,
            } => self.generate_partial_proof(witness, child_proof, (cells_proof, cells_vk)),
        }
    }

    fn generate_leaf_proof(
        &self,
        witness: LeafCircuit,
        cells_proof: CellsProof,
    ) -> Result<Vec<u8>> {
        let (p, cells_set) = cells_proof;
        let cells_proof = ProofWithVK::deserialize(&p)?;
        let leaf = leaf::RecursiveLeafInput {
            witness,
            cells_proof,
            cells_set,
        };
        let proof = self.row_set.generate_proof(&self.leaf, [], [], leaf)?;
        ProofWithVK::new(proof, self.leaf.circuit_data().verifier_only.clone()).serialize()
    }

    fn generate_full_proof(
        &self,
        witness: FullNodeCircuit,
        left_proof: Vec<u8>,
        right_proof: Vec<u8>,
        cells_proof: CellsProof,
    ) -> Result<Vec<u8>> {
        let (p, cells_set) = cells_proof;
        let cells_proof = ProofWithVK::deserialize(&p)?;
        let full = full_node::RecursiveFullInput {
            witness,
            cells_proof,
            cells_set,
        };
        let (left_proof, left_vd) = ProofWithVK::deserialize(&left_proof)?.into();
        let (right_proof, right_vd) = ProofWithVK::deserialize(&right_proof)?.into();
        let proof = self.row_set.generate_proof(
            &self.full,
            [left_proof, right_proof],
            [&left_vd, &right_vd],
            full,
        )?;
        ProofWithVK::new(proof, self.full.circuit_data().verifier_only.clone()).serialize()
    }

    fn generate_partial_proof(
        &self,
        witness: PartialNodeCircuit,
        child_proof: Vec<u8>,
        cells_proof: CellsProof,
    ) -> Result<Vec<u8>> {
        let (p, cells_set) = cells_proof;
        let cells_proof = ProofWithVK::deserialize(&p)?;
        let partial = partial_node::RecursivePartialInput {
            witness,
            cells_proof,
            cells_set,
        };
        let (child_proof, child_vd) = ProofWithVK::deserialize(&child_proof)?.into();
        let proof =
            self.row_set
                .generate_proof(&self.partial, [child_proof], [&child_vd], partial)?;
        ProofWithVK::new(proof, self.partial.circuit_data().verifier_only.clone()).serialize()
    }
}

///  A wrapper type around the information needed for all three cases
///  of the  rows circuits
type CellsProof = (Vec<u8>, RecursiveCircuits<F, C, D>);

/// Enum holding all the inputs necessary to generate
/// rows tree related proofs
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum CircuitInput {
    Leaf {
        witness: leaf::LeafCircuit,
        cells_proof: Vec<u8>,
    },
    Full {
        witness: full_node::FullNodeCircuit,
        left_proof: Vec<u8>,
        right_proof: Vec<u8>,
        cells_proof: Vec<u8>,
    },
    Partial {
        witness: partial_node::PartialNodeCircuit,
        child_proof: Vec<u8>,
        cells_proof: Vec<u8>,
    },
}

impl CircuitInput {
    pub fn leaf(
        identifier: u64,
        value: U256,
        is_multiplier: bool,
        row_unique_data: HashOutput,
        cells_proof: Vec<u8>,
    ) -> Result<Self> {
        let cell = Cell::new(F::from_canonical_u64(identifier), value, is_multiplier);
        let secondary_index_cell = SecondaryIndexCell::new(cell, row_unique_data.into());
        Ok(CircuitInput::Leaf {
            witness: secondary_index_cell.into(),
            cells_proof,
        })
    }

    pub fn full(
        identifier: u64,
        value: U256,
        is_multiplier: bool,
        row_unique_data: HashOutput,
        left_proof: Vec<u8>,
        right_proof: Vec<u8>,
        cells_proof: Vec<u8>,
    ) -> Result<Self> {
        let cell = Cell::new(F::from_canonical_u64(identifier), value, is_multiplier);
        let secondary_index_cell = SecondaryIndexCell::new(cell, row_unique_data.into());
        Ok(CircuitInput::Full {
            witness: secondary_index_cell.into(),
            left_proof,
            right_proof,
            cells_proof,
        })
    }

    pub fn partial(
        identifier: u64,
        value: U256,
        is_multiplier: bool,
        is_child_left: bool,
        row_unique_data: HashOutput,
        child_proof: Vec<u8>,
        cells_proof: Vec<u8>,
    ) -> Result<Self> {
        let cell = Cell::new(F::from_canonical_u64(identifier), value, is_multiplier);
        let secondary_index_cell = SecondaryIndexCell::new(cell, row_unique_data.into());
        let witness = PartialNodeCircuit::new(secondary_index_cell, is_child_left);
        Ok(CircuitInput::Partial {
            witness,
            child_proof,
            cells_proof,
        })
    }
}

pub fn extract_hash_from_proof(proof: &[u8]) -> Result<HashOut<F>> {
    let p = ProofWithVK::deserialize(proof)?;
    Ok(PublicInputs::from_slice(&p.proof.public_inputs).root_hash())
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::cells_tree;
    use itertools::Itertools;
    use mp2_common::{
        group_hashing::weierstrass_to_point,
        poseidon::{empty_poseidon_hash, H},
        utils::ToFields,
        F,
    };
    use mp2_test::log::init_logging;
    use partial_node::test::partial_safety_check;
    use plonky2::{
        field::types::{PrimeField64, Sample},
        hash::hash_types::HashOut,
        plonk::{
            circuit_data::VerifierOnlyCircuitData, config::Hasher, proof::ProofWithPublicInputs,
        },
    };
    use recursion_framework::framework_testing::TestingRecursiveCircuits;
    use std::iter::once;

    const CELL_IO_LEN: usize = cells_tree::PublicInputs::<F>::total_len();

    struct TestParams {
        cells_test: TestingRecursiveCircuits<F, C, D, CELL_IO_LEN>,
        params: PublicParameters,
        // always using the same cells_proof at each  row node
        // to save on test time
        cells_proof: ProofWithPublicInputs<F, C, D>,
        cells_vk: VerifierOnlyCircuitData<C, D>,
        leaf1: SecondaryIndexCell,
        leaf2: SecondaryIndexCell,
        full: SecondaryIndexCell,
        partial: SecondaryIndexCell,
    }

    impl TestParams {
        fn build() -> Result<Self> {
            let cells_test = TestingRecursiveCircuits::<F, C, D, CELL_IO_LEN>::default();
            let params = PublicParameters::build(cells_test.get_recursive_circuit_set());
            let cells_pi = cells_tree::PublicInputs::sample(false);
            let cells_proof =
                cells_test.generate_input_proofs::<1>([cells_pi.clone().try_into().unwrap()])?;
            let cells_vk = cells_test.verifier_data_for_input_proofs::<1>()[0].clone();
            //  leaf1 - leaf2  =>  full_node => partial_node
            let identifier = F::rand();
            //let v1 = U256::from(rng.gen::<[u8; 32]>());
            let v1 = U256::from(10);
            let v_full = v1 + U256::from(10);
            let v2 = v_full + U256::from(10);
            let v_partial = v2 + U256::from(10); // full is left child of partial

            //           40  (partial)
            //          /
            //        20 (full)
            //      /   \
            //  10        30  (leaves)
            Ok(TestParams {
                cells_test,
                params,
                cells_proof: cells_proof[0].clone(),
                cells_vk,
                leaf1: SecondaryIndexCell::new(Cell::new(identifier, v1, false), HashOut::rand()),
                leaf2: SecondaryIndexCell::new(Cell::new(identifier, v2, false), HashOut::rand()),
                full: SecondaryIndexCell::new(
                    Cell::new(identifier, v_full, false),
                    HashOut::rand(),
                ),
                partial: SecondaryIndexCell::new(
                    Cell::new(identifier, v_partial, false),
                    HashOut::rand(),
                ),
            })
        }

        fn cells_pi(&self) -> cells_tree::PublicInputs<F> {
            cells_tree::PublicInputs::from_slice(&self.cells_proof.public_inputs)
        }
        fn cells_proof_vk(&self) -> ProofWithVK {
            ProofWithVK::new(self.cells_proof.clone(), self.cells_vk.clone())
        }
    }

    #[test]
    fn test_rows_tree_api() -> Result<()> {
        init_logging();
        log::info!("Generating parameters");
        let params = TestParams::build()?;
        log::info!("Generating leaf proof 1");
        let leaf1 = generate_leaf_proof(&params, &params.leaf1)?;
        log::info!("Generating leaf proof 2");
        let leaf2 = generate_leaf_proof(&params, &params.leaf2)?;
        let children_proof = [leaf1.clone(), leaf2.clone()];
        log::info!("Generating full proof (from leaf 1 and leaf 2)");
        let full_proof = generate_full_proof(&params, children_proof)?;
        log::info!("Generating partial proof (from full proof)");
        let _ = generate_partial_proof(&params, true, full_proof)?;
        log::info!("Test done");
        Ok(())
    }

    fn generate_partial_proof(
        p: &TestParams,
        is_left: bool,
        child_proof_buff: Vec<u8>,
    ) -> Result<Vec<u8>> {
        let secondary_index_cell = &p.partial;
        let id = secondary_index_cell.cell.identifier;
        let value = secondary_index_cell.cell.value;
        let row_unique_data = secondary_index_cell.row_unique_data.into();
        let row_digest = secondary_index_cell.digest(&p.cells_pi());

        let child_proof = ProofWithVK::deserialize(&child_proof_buff)?;
        let child_pi = PublicInputs::from_slice(&child_proof.proof.public_inputs);
        let child_min = child_pi.min_value();
        let child_max = child_pi.max_value();

        partial_safety_check(child_min, child_max, value, is_left);

        let input = CircuitInput::partial(
            id.to_canonical_u64(),
            value,
            false,
            is_left,
            row_unique_data,
            child_proof_buff.clone(),
            p.cells_proof_vk().serialize()?,
        )?;
        let proof = p
            .params
            .generate_proof(input, p.cells_test.get_recursive_circuit_set().clone())?;
        let pi = ProofWithVK::deserialize(&proof)?.proof.public_inputs;
        let pi = PublicInputs::from_slice(&pi);

        // Check root hash
        {
            // node_min = left ? child_proof.min : index_value
            // node_max = left ? index_value : child_proof.max
            let (node_min, node_max) = match is_left {
                true => (pi.min_value(), value),
                false => (value, pi.max_value()),
            };
            // Poseidon(p1.H || p2.H || node_min || node_max || index_id || index_value ||p.H)) as H
            let child_hash = child_pi.root_hash().to_fields();
            let empty_hash = empty_poseidon_hash().to_fields();
            let input_hash = match is_left {
                true => [child_hash, empty_hash].concat(),
                false => [empty_hash, child_hash].concat(),
            };
            let inputs = input_hash
                .into_iter()
                .chain(node_min.to_fields())
                .chain(node_max.to_fields())
                .chain(once(id))
                .chain(value.to_fields())
                .chain(p.cells_pi().node_hash().to_fields())
                .collect_vec();
            let exp_root_hash = H::hash_no_pad(&inputs);
            assert_eq!(pi.root_hash(), exp_root_hash);
        }
        // Check individual digest
        assert_eq!(
            pi.individual_digest_point(),
            (row_digest.individual_vd + weierstrass_to_point(&child_pi.individual_digest_point()))
                .to_weierstrass()
        );
        // Check multiplier digest
        assert_eq!(
            pi.multiplier_digest_point(),
            row_digest.multiplier_vd.to_weierstrass()
        );
        // Check minimum value
        assert_eq!(pi.min_value(), value.min(child_min));
        // Check maximum value
        assert_eq!(pi.max_value(), value.max(child_max));
        // Check multiplier counter
        assert_eq!(pi.multiplier_counter(), row_digest.multiplier_cnt);

        Ok(vec![])
    }

    fn generate_full_proof(p: &TestParams, child_proof: [Vec<u8>; 2]) -> Result<Vec<u8>> {
        let secondary_index_cell = &p.full;
        let id = secondary_index_cell.cell.identifier;
        let value = secondary_index_cell.cell.value;
        let row_unique_data = secondary_index_cell.row_unique_data.into();
        let row_digest = secondary_index_cell.digest(&p.cells_pi());

        let input = CircuitInput::full(
            id.to_canonical_u64(),
            value,
            false,
            row_unique_data,
            child_proof[0].to_vec(),
            child_proof[1].to_vec(),
            p.cells_proof_vk().serialize()?,
        )?;
        let left_proof = ProofWithVK::deserialize(&child_proof[0])?;
        let left_pi = PublicInputs::from_slice(&left_proof.proof.public_inputs);
        let right_proof = ProofWithVK::deserialize(&child_proof[1])?;
        let right_pi = PublicInputs::from_slice(&right_proof.proof.public_inputs);
        assert!(left_pi.max_value() < value);
        assert!(value < right_pi.min_value());
        let proof = p
            .params
            .generate_proof(input, p.cells_test.get_recursive_circuit_set().clone())?;
        let pi = ProofWithVK::deserialize(&proof)?.proof.public_inputs;
        let pi = PublicInputs::from_slice(&pi);

        // Check root hash
        {
            // Poseidon(p1.H || p2.H || node_min || node_max || index_id || index_value ||p.H)) as H
            let inputs = left_pi
                .root_hash()
                .to_fields()
                .into_iter()
                .chain(right_pi.root_hash().to_fields())
                .chain(left_pi.min_value().to_fields())
                .chain(right_pi.max_value().to_fields())
                .chain(once(id))
                .chain(value.to_fields())
                .chain(p.cells_pi().node_hash().to_fields())
                .collect_vec();
            let hash = H::hash_no_pad(&inputs);
            assert_eq!(hash, pi.root_hash());
        }
        // Check individual digest
        assert_eq!(
            pi.individual_digest_point(),
            (row_digest.individual_vd
                + weierstrass_to_point(&left_pi.individual_digest_point())
                + weierstrass_to_point(&right_pi.individual_digest_point()))
            .to_weierstrass()
        );
        // Check multiplier digest
        assert_eq!(
            pi.multiplier_digest_point(),
            row_digest.multiplier_vd.to_weierstrass()
        );
        // Check multiplier counter
        assert_eq!(pi.multiplier_counter(), row_digest.multiplier_cnt);

        Ok(proof)
    }

    fn generate_leaf_proof(p: &TestParams, row: &SecondaryIndexCell) -> Result<Vec<u8>> {
        let id = row.cell.identifier;
        let value = row.cell.value;
        let row_unique_data = row.row_unique_data.into();
        let row_digest = row.digest(&p.cells_pi());

        //  generate row leaf proof
        let input = CircuitInput::leaf(
            id.to_canonical_u64(),
            value,
            false,
            row_unique_data,
            p.cells_proof_vk().serialize()?,
        )?;

        let proof = p
            .params
            .generate_proof(input, p.cells_test.get_recursive_circuit_set().clone())?;
        let pi = ProofWithVK::deserialize(&proof)
            .unwrap()
            .proof
            .public_inputs;
        let pi = PublicInputs::from_slice(&pi);

        // Check root hash
        {
            let value = value.to_fields();
            let empty_hash = empty_poseidon_hash().to_fields();
            let inputs = empty_hash
                .iter()
                .chain(empty_hash.iter())
                .chain(value.iter())
                .chain(value.iter())
                .chain(once(&id))
                .chain(value.iter())
                .chain(p.cells_pi().to_node_hash_raw())
                .cloned()
                .collect_vec();
            let exp_root_hash = H::hash_no_pad(&inputs);
            assert_eq!(pi.root_hash(), exp_root_hash);
        }
        // Check individual digest
        assert_eq!(
            pi.individual_digest_point(),
            row_digest.individual_vd.to_weierstrass()
        );
        // Check multiplier digest
        assert_eq!(
            pi.multiplier_digest_point(),
            row_digest.multiplier_vd.to_weierstrass()
        );
        // Check minimum value
        assert_eq!(pi.min_value(), value);
        // Check maximum value
        assert_eq!(pi.max_value(), value);
        // Check multiplier counter
        assert_eq!(pi.multiplier_counter(), row_digest.multiplier_cnt);

        Ok(proof)
    }
}
