-- String inputs:
--  * zk_table: the zkTable name
--  * core_keys_query: a query returning the core keys, i.e. the keys directly
--    touched by the zkQuery.
-- Placeholders:
--  * $1: start of the block range
--  * $2: end of the block range
--  * $3: downward recursion limit for descendance expansion
--
-- Output:
-- A table of all the keys on the union of paths from each core key to the root,
-- each expanded two level down.


-- The `descendance` CTE starts from a set of keys, and recursively additionally
-- fetches their descendance, up to two levels down.
WITH RECURSIVE descendance (is_core, key, parent, left_child, right_child, __valid_from, __valid_until, payload, depth) AS (
     -- Initialisation query for the descendance: all the rows corresponding to
     -- the union of the paths to the root of the core keys, annotated with
     -- depth = 0
     SELECT ascendance_expanded.is_core, {zk_table}.key, parent, left_child, right_child, __valid_from, __valid_until, payload, 0
       FROM {zk_table}
       -- Right join the zkTable on the ephemeral table generated by the
       -- ascendance CTE to merge their `is_core` flag with the other columns of
       -- the zkTable.
       RIGHT JOIN (
         -- The `ascendance` CTE starts from a set of keys, then recursively
         -- moves up the tree and accumulate all the keys encountered up to the
         -- tree root.
         WITH RECURSIVE ascendance (is_core, key, left_child, right_child, __valid_from, __valid_until) AS (
         -- All the keys selected by the provided "touched keys" query,
         -- annotated with a `is_core` flag set to 1.
         SELECT is_core, core_keys.key, left_child, right_child, __valid_from, __valid_until
           FROM {zk_table}
           -- Right join the zkTable on the set of keys provided by the core key
           -- query annotated with the `is_core` flag set to 1 to find their
           -- other attributes in the zkTable.
           RIGHT JOIN (SELECT 1 AS is_core, key FROM ({core_keys_query}) _core_keys_query) core_keys
           ON core_keys.key = {zk_table}.key
         UNION
         -- General recursion case: find the rows in the given block range that
         -- are the parent of at least one of the already accumulated rows, with
         -- the `is_core` flag set to 0.
         SELECT 0, parent.key, parent.left_child, parent.right_child, parent.__valid_from, parent.__valid_until
           FROM {zk_table} parent, ascendance current
           WHERE current.key IN (parent.left_child, parent.right_child) AND parent.__valid_from <= $1 AND parent.__valid_until >= $2
         )
         SELECT
           -- aggregate the max. of is_core to ensure that core keys keep their
           -- flag
           MAX(is_core) AS is_core, key
         FROM ascendance
         -- Deduplicate by (is_core, key)
         GROUP BY is_core, key) ascendance_expanded
       -- RIGHT JOIN criterion
       ON ascendance_expanded.key = {zk_table}.key
   UNION
   -- General recursion case: find the rows in the given block range and within
   -- the given downward recursion limit that are a child of at least one of the
   -- already accumulated rows.
   SELECT 0, child.key, child.parent, child.left_child, child.right_child, child.__valid_from, child.__valid_until, payload, depth + 1
     FROM {zk_table} child, descendance parent
     WHERE child.key IN (parent.left_child, parent.right_child) AND child.__valid_from <= $1 AND child.__valid_until >= $2 AND depth < $3
 ) SELECT
   -- is_core may be 1 (if the row is explicitely a core key) or 0 (if it has been
   -- added by path traversal). To preserve the core key flag, we aggregate by
   -- max. of is_core, that will always be 1 if the key is in the core set.
   MAX(is_core) AS is_core,
   -- Expand the block ranges [[__valid_from, __valid_until]] into
   -- (__valid_until - __valid_from) individual rows, clamped within
   -- [[min_block, max_block]]
   generate_series(GREATEST(__valid_from, $1), LEAST(__valid_until, $2)) AS block,
   -- Normal columns
   key, parent, left_child, right_child, payload
   FROM
     descendance
   -- Results must be deduplicated according to this tuple of attributes
   GROUP BY (is_core, key, parent, left_child, right_child, __valid_from, __valid_until, payload)



-- Example run:
-- WITH RECURSIVE descendance (is_core, key, left_child, right_child, __valid_from, __valid_until, payload, depth) AS (
--       -- Initialisation query for the descendance: all the rows corresponding to
--       -- the union of the paths to the root of the core keys, annotated with
--       -- depth = 0
--       SELECT ascendance_expanded.is_core, thousand.key, left_child, right_child, __valid_from, __valid_until, payload, 0
--         FROM thousand
--         -- Right join the zkTable on the ephemeral table generated by the
--         -- ascendance CTE to merge their `is_core` flag with the other columns of
--         -- the zkTable.
--         RIGHT JOIN (
--           -- The `ascendance` CTE starts from a set of keys, then recursively
--           -- moves up the tree and accumulate all the keys encountered up to the
--           -- tree root.
--           WITH RECURSIVE ascendance (is_core, key, left_child, right_child, __valid_from, __valid_until) AS (
--           -- All the keys selected by the provided "touched keys" query,
--           -- annotated with a `is_core` flag set to 1.
--           SELECT is_core, core_keys.key, left_child, right_child, __valid_from, __valid_until
--             FROM thousand
--             -- Right join the zkTable on the set of keys provided by the core key
--             -- query annotated with the `is_core` flag set to 1 to find their
--             -- other attributes in the zkTable.
--             RIGHT JOIN (SELECT 1 AS is_core, key FROM (SELECT key FROM thousand WHERE key = ANY(ARRAY['\x0000000000000061'::bytea,'\x0000000000000060'::bytea, '\x000000000000032a'::bytea]) AND __valid_from <= 1 AND __valid_until >= 1) _core_keys_query) core_keys on core_keys.key = thousand.key
--           UNION
--           -- General recursion case: find the rows in the given block range that
--           -- are the parent of at least one of the already accumulated rows, with
--           -- the `is_core` flag set to 0.
--           SELECT 0, parent.key, parent.left_child, parent.right_child, parent.__valid_from, parent.__valid_until
--             FROM thousand parent, ascendance current
--             WHERE current.key IN (parent.left_child, parent.right_child) AND parent.__valid_from <= 1 AND parent.__valid_until >= 1
--           ) SELECT max(is_core) AS is_core, key FROM ascendance GROUP BY is_core, key) ascendance_expanded ON ascendance_expanded.key = thousand.key
--     UNION
--     -- General recursion case: find the rows in the given block range and within
--     -- the given downward recursion limit that are a child of at least one of the
--     -- already accumulated rows.
--     SELECT 0, child.key, child.left_child, child.right_child, child.__valid_from, child.__valid_until, child.payload, depth + 1
--       FROM thousand child, descendance parent
--       WHERE child.key IN (parent.left_child, parent.right_child) AND child.__valid_from <= 1 AND child.__valid_until >= 1 AND depth < 2
--   ) SELECT
--     -- is_core may be 1 (if the row is explicitely a core key) or 0 (if it has been
--     -- added by path traversal). To preserve the core key flag, we aggregate by
--     -- max. of is_core, that will always be 1 if the key is in the core set.
--     max(is_core) AS is_core,
--     -- Expand the block ranges [[__valid_from, __valid_until]] into (__valid_until - __valid_from) individual rows
--     generate_series(GREATEST(__valid_from, 1), LEAST(__valid_until, 1)) AS block,
--     key,
--     left_child, right_child, payload
--     FROM
--       descendance
--     -- Results must be deduplicated according to this tuple of attributes
--     GROUP BY (is_core, key, left_child, right_child, __valid_from, __valid_until, payload)
