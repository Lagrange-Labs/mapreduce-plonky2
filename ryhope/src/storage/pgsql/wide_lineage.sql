-- String inputs:
--  * zk_table: the zkTable name
--  * core_keys_query: a query returning the core keys, i.e. the keys directly
--    touched by the zkQuery.
-- Placeholders:
--  * $1: start of the epoch range
--  * $2: end of the epoch range
--  * $3: downward recursion limit for descendance expansion
--
-- Output:
-- A table of all the keys on the union of paths from each core key to the root,
-- each expanded two level down.


-- The `descendance` CTE starts from a set of keys, and recursively additionally
-- fetches their descendance, up to two levels down.
WITH RECURSIVE descendance (is_core, key, parent, left_child, right_child, subtree_size, {VALID_FROM}, {VALID_UNTIL}, {PAYLOAD}, depth) AS (
     -- Initialisation query for the descendance: all the rows corresponding to
     -- the union of the paths to the root of the core keys, annotated with
     -- depth = 0
     SELECT ascendance_expanded.is_core, {zk_table}.key, parent, left_child, right_child, subtree_size, {zk_table}.{VALID_FROM}, {zk_table}.{VALID_UNTIL}, {PAYLOAD}, 0
       FROM {zk_table}
       -- Right join the zkTable on the ephemeral table generated by the
       -- ascendance CTE to merge their `is_core` flag with the other columns of
       -- the zkTable.
       RIGHT JOIN (
         -- The `ascendance` CTE starts from a set of keys, then recursively
         -- moves up the tree and accumulate all the keys encountered up to the
         -- tree root.
         WITH RECURSIVE ascendance (is_core, key, left_child, right_child, {VALID_FROM}, {VALID_UNTIL}) AS (
           -- All the keys selected by the provided "touched keys" query,
           -- annotated with a `is_core` flag set to 1.
           SELECT is_core, core_keys.key, left_child, right_child, {zk_table}.{VALID_FROM}, {zk_table}.{VALID_UNTIL}
             FROM {zk_table}
             -- Right join the zkTable on the set of keys provided by the core key
             -- query annotated with the `is_core` flag set to 1 to find their
             -- other attributes in the zkTable.
             --
             -- XXX: this assumes that the block range is contiguous when
             -- translating it back to a range
             RIGHT JOIN
               (SELECT 1 AS is_core, key, MIN(block) AS {VALID_FROM}, MAX(block) AS {VALID_UNTIL}
                  FROM ({core_keys_query}) _core_keys_query
                  GROUP BY key) core_keys
             ON core_keys.key = {zk_table}.key
                AND NOT ({zk_table}.{VALID_FROM} > core_keys.{VALID_UNTIL} OR core_keys.{VALID_FROM} > {zk_table}.{VALID_UNTIL})
           UNION
           -- General recursion case: find the rows in the given epoch range that
           -- are the parent of at least one of the already accumulated rows, with
           -- the `is_core` flag set to 0.
           SELECT 0, parent.key, parent.left_child, parent.right_child, parent.{VALID_FROM}, parent.{VALID_UNTIL}
             FROM {zk_table} parent, ascendance current
             WHERE current.key IN (parent.left_child, parent.right_child)
                   AND NOT (parent.{VALID_UNTIL} < current.{VALID_FROM} or parent.{VALID_FROM} > current.{VALID_UNTIL})
         )
         SELECT
           -- aggregate the max. of is_core to ensure that core keys keep their
           -- flag
           MAX(is_core) AS is_core, key, {VALID_FROM}, {VALID_UNTIL}
         FROM ascendance
         -- -- Deduplicate by (is_core, key, [lifetime])
         GROUP BY is_core, key, {VALID_FROM}, {VALID_UNTIL}
         ) ascendance_expanded
       -- RIGHT JOIN criterion
       ON ascendance_expanded.key = {zk_table}.key
   UNION
   -- General recursion case: find the rows in the given epoch range and within
   -- the given downward recursion limit that are a child of at least one of the
   -- already accumulated rows.
   SELECT 0, child.key, child.parent, child.left_child, child.right_child, child.subtree_size, child.{VALID_FROM}, child.{VALID_UNTIL}, child.{PAYLOAD}, depth + 1
     FROM {zk_table} child, descendance parent
     WHERE
       child.key IN (parent.left_child, parent.right_child)
       AND depth < $3
       AND NOT (child.{VALID_FROM} > parent.{VALID_UNTIL} OR child.{VALID_UNTIL}  < parent.{VALID_FROM})
 ) SELECT
   -- is_core may be 1 (if the row is explicitely a core key) or 0 (if it has been
   -- added by path traversal). To preserve the core key flag, we aggregate by
   -- max. of is_core, that will always be 1 if the key is in the core set.
   MAX(is_core) AS is_core,
   -- Expand the epoch ranges [[{VALID_FROM}, {VALID_UNTIL}]] into
   -- ({VALID_UNTIL} - {VALID_FROM}) individual rows, clamped within
   -- [[min_block, max_block]]
   generate_series(GREATEST({VALID_FROM}, $1), LEAST({VALID_UNTIL}, $2)) AS epoch,
   -- Normal columns
   key, parent, left_child, right_child, subtree_size, {PAYLOAD}
   FROM
     descendance
   -- Results must be deduplicated according to this tuple of attributes
   GROUP BY (is_core, key, parent, left_child, right_child, subtree_size, {VALID_FROM}, {VALID_UNTIL}, {PAYLOAD})
