-- String inputs:
--  * zk_table: the zkTable name
--  * core_keys_query: a query returning the core keys, i.e. the keys directly
--    touched by the zkQuery, providing the columns {KEY} and {EPOCH}.
--  * max_depth: downward recursion limit for descendance expansion
-- Placeholders:
--  * $1: start of the epoch range
--  * $2: end of the epoch range
--
-- Output:
-- A table of all the keys on the union of paths from each core key to the root,
-- each expanded two level down.


-- The `descendance` CTE starts from a set of keys, and recursively additionally
-- fetches their descendance, up to two levels down.
WITH RECURSIVE descendance (is_core, {KEY}, {PARENT}, {LEFT_CHILD}, {RIGHT_CHILD}, {SUBTREE_SIZE}, {VALID_FROM}, {VALID_UNTIL}, {PAYLOAD}, depth) AS (
     -- Initialisation query for the descendance: all the rows corresponding to
     -- the union of the paths to the root of the core keys, annotated with
     -- depth = 0
     SELECT ascendance_expanded.is_core, {zk_table}.{KEY}, {PARENT}, {LEFT_CHILD}, {RIGHT_CHILD}, {SUBTREE_SIZE}, {zk_table}.{VALID_FROM}, {zk_table}.{VALID_UNTIL}, {PAYLOAD}, 0
       FROM {zk_table}
       -- Right join the zkTable on the ephemeral table generated by the
       -- ascendance CTE to merge their `is_core` flag with the other columns of
       -- the zkTable.
       RIGHT JOIN (
         -- The `ascendance` CTE starts from a set of keys, then recursively
         -- moves up the tree and accumulate all the keys encountered up to the
         -- tree root.
         WITH RECURSIVE ascendance (is_core, {KEY}, {LEFT_CHILD}, {RIGHT_CHILD}, {VALID_FROM}, {VALID_UNTIL}) AS (
           -- All the keys selected by the provided "touched keys" query,
           -- annotated with a `is_core` flag set to 1.
           SELECT is_core, core_keys.{KEY}, {LEFT_CHILD}, {RIGHT_CHILD}, {zk_table}.{VALID_FROM}, {zk_table}.{VALID_UNTIL}
             FROM {zk_table}
             -- Right join the zkTable on the set of keys provided by the core key
             -- query annotated with the `is_core` flag set to 1 to find their
             -- other attributes in the zkTable.
             --
             -- XXX: this assumes that the block range is contiguous when
             -- translating it back to a range
             RIGHT JOIN
               (SELECT 1 AS is_core, {KEY}, MIN({EPOCH}) AS {VALID_FROM}, MAX({EPOCH}) AS {VALID_UNTIL}
                  FROM ({core_keys_query}) _core_keys_query
                  GROUP BY {KEY}) core_keys
             ON core_keys.{KEY} = {zk_table}.{KEY}
                AND NOT ({zk_table}.{VALID_FROM} > core_keys.{VALID_UNTIL} OR core_keys.{VALID_FROM} > {zk_table}.{VALID_UNTIL})
           UNION
           -- General recursion case: find the rows in the given epoch range that
           -- are the parent of at least one of the already accumulated rows, with
           -- the `is_core` flag set to 0.
           SELECT 0, parent.{KEY}, parent.{LEFT_CHILD}, parent.{RIGHT_CHILD}, parent.{VALID_FROM}, parent.{VALID_UNTIL}
             FROM {zk_table} parent, ascendance current
             WHERE current.{KEY} IN (parent.{LEFT_CHILD}, parent.{RIGHT_CHILD})
                   AND NOT (parent.{VALID_UNTIL} < current.{VALID_FROM} or parent.{VALID_FROM} > current.{VALID_UNTIL})
         )
         SELECT
           -- aggregate the max. of is_core to ensure that core keys keep their
           -- flag
           MAX(is_core) AS is_core, {KEY}, {VALID_FROM}, {VALID_UNTIL}
         FROM ascendance
         -- -- Deduplicate by (is_core, key, [lifetime])
         GROUP BY is_core, {KEY}, {VALID_FROM}, {VALID_UNTIL}
         ) ascendance_expanded
       -- RIGHT JOIN criterion
       ON ascendance_expanded.{KEY} = {zk_table}.{KEY}
   UNION
   -- General recursion case: find the rows in the given epoch range and within
   -- the given downward recursion limit that are a child of at least one of the
   -- already accumulated rows.
   SELECT 0, child.{KEY}, child.{PARENT}, child.{LEFT_CHILD}, child.{RIGHT_CHILD}, child.{SUBTREE_SIZE}, child.{VALID_FROM}, child.{VALID_UNTIL}, child.{PAYLOAD}, depth + 1
     FROM {zk_table} child, descendance parent
     WHERE
       child.{KEY} IN (parent.{LEFT_CHILD}, parent.{RIGHT_CHILD})
       AND depth < {max_depth}
       AND NOT (child.{VALID_FROM} > parent.{VALID_UNTIL} OR child.{VALID_UNTIL}  < parent.{VALID_FROM})
 ) SELECT
   -- is_core may be 1 (if the row is explicitely a core key) or 0 (if it has been
   -- added by path traversal). To preserve the core key flag, we aggregate by
   -- max. of is_core, that will always be 1 if the key is in the core set.
   MAX(is_core) AS is_core,
   -- Epoch column
   {USER_EPOCH} AS {EPOCH},
   -- Normal columns
   {KEY}, {PARENT}, {LEFT_CHILD}, {RIGHT_CHILD}, {SUBTREE_SIZE}, {PAYLOAD}
   FROM
     descendance JOIN (
          SELECT {USER_EPOCH}, {INCREMENTAL_EPOCH} FROM {mapper_table_name} WHERE {USER_EPOCH} >= $1 AND {USER_EPOCH} <= $2  
      ) AS __mapper ON {VALID_FROM} <= {INCREMENTAL_EPOCH} AND {VALID_UNTIL} >= {INCREMENTAL_EPOCH}
   -- Results must be deduplicated according to this tuple of attributes
   GROUP BY (is_core, {KEY}, {PARENT}, {LEFT_CHILD}, {RIGHT_CHILD}, {SUBTREE_SIZE}, {USER_EPOCH}, {PAYLOAD})
