//! The prover used to generate the Groth16 proof and Solidity verifier contract

use crate::{proof::Groth16Proof, C, D, F};
use anyhow::Result;
use plonky2::{plonk::circuit_data::CircuitData, plonk::proof::ProofWithPublicInputs};
use plonky2x::backend::{
    circuit::{DefaultParameters, Groth16WrapperParameters},
    wrapper::wrap::WrappedCircuit,
};
use std::{
    ffi::OsStr,
    path::{Path, PathBuf},
    process::Command,
};

/// The output dir for wrapped proof data
const WRAPPED_PROOF_DIR: &str = "wrapped";
/// The generated filename of Groth16 proof
const GROTH16_PROOF_FILE: &str = "groth16.proof";
/// The generated file of Solidity verifier contract
const VERIFIER_CONRTACT_FILE: &str = "verifier.sol";

/// Groth16 prover configuration
#[derive(Debug)]
pub struct Groth16ProverConfig {
    pub prover_cmd: String,
    pub data_dir: String,
    pub circuit_data: Option<CircuitData<F, C, D>>,
}

/// The Groth16 prover is used to generate the wrapped proof from normal plonky2
/// proof, then employ a Groth16 prover process of gnark-plonky2-verifier to
/// generate a Groth16 proof which could be verified by a Solidity verifier
/// contract.
#[derive(Debug)]
pub struct Groth16Prover {
    /// Prover configuration
    config: Groth16ProverConfig,
    /// Wrapped circuit instance
    wrapper: WrappedCircuit<DefaultParameters, Groth16WrapperParameters, D>,
}

impl Groth16Prover {
    pub fn new(mut config: Groth16ProverConfig) -> Self {
        let circuit_data = config.circuit_data.take().expect("Must have circuit-data");
        let wrapper = WrappedCircuit::build_from_raw_circuit(circuit_data);

        Self { config, wrapper }
    }

    /// Generate the wrapped proof from normal plonky2 proof.
    pub fn prove(&self, proof: &ProofWithPublicInputs<F, C, D>) -> Result<Groth16Proof> {
        self.prove_and_generate_contract(proof, false)
    }

    /// Generate the wrapped proof and Solidity verifier contract for optional.
    pub fn prove_and_generate_contract(
        &self,
        proof: &ProofWithPublicInputs<F, C, D>,
        is_contract_generated: bool,
    ) -> Result<Groth16Proof> {
        // Construct the file paths to share with Go prover.
        let wrapped_proof_dir = self.full_data_path(WRAPPED_PROOF_DIR);
        let groth16_proof_file = self.full_data_path(GROTH16_PROOF_FILE);
        let verifier_contract_file = if is_contract_generated {
            Some(self.full_data_path(VERIFIER_CONRTACT_FILE))
        } else {
            None
        };

        // Generate the wrapped proof and save to files.
        let wrapped_proof = self.wrapper.prove(proof)?;
        wrapped_proof.save(&wrapped_proof_dir)?;

        // Employ the Go prover command to generate the Groth16 proof and
        // Solidity verifier contract.
        // TODO: this is inefficient, since always need to do trusted-setup in
        // the Go prover. Suppose to use [gobuild](https://github.com/myagley/gobuild)
        // to let Rust call C functions build from Go code.
        self.run_prover_command(
            &wrapped_proof_dir,
            &groth16_proof_file,
            &verifier_contract_file,
        )?;

        // Read the Groth16 proof from the file generated by Go prover.
        Groth16Proof::from_file(groth16_proof_file)
    }

    /// Employ the Go prover command to generate the Groth16 proof and Solidity
    /// verifier contract.
    fn run_prover_command<S: AsRef<OsStr>>(
        &self,
        in_dir: &S,
        out_proof: &S,
        out_contract: &Option<S>,
    ) -> Result<()> {
        let mut cmd = Command::new(&self.config.prover_cmd);

        cmd.arg("-in-dir")
            .arg(in_dir)
            .arg("-out-proof")
            .arg(out_proof);

        if let Some(out_contract) = out_contract {
            cmd.arg("-out-contract");
            cmd.arg(out_contract);
        }

        cmd.spawn()?.wait_with_output()?;

        Ok(())
    }

    /// Combine the data path with filename.
    fn full_data_path(&self, name: &str) -> PathBuf {
        Path::new(&self.config.data_dir).join(name)
    }
}
