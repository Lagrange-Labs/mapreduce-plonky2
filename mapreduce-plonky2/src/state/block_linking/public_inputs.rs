//! Public inputs generated by this circuit

use super::BlockLinkingWires;
use crate::{
    keccak::PACKED_HASH_LEN,
    mpt_sequential::PAD_LEN,
    storage::PublicInputs as StorageInputs,
    types::{CURVE_TARGET_LEN, PACKED_ADDRESS_LEN},
};
use plonky2::{
    field::extension::Extendable,
    hash::hash_types::{RichField, NUM_HASH_OUT_ELTS},
    iop::target::Target,
    plonk::circuit_builder::CircuitBuilder,
};

/// This is a wrapper around an array of targets set as public inputs of any
/// proof generated in this module. They all share the same structure.
/// `H` Block header hash
/// `N` Block number in u32 format
/// `PREV_H` Header hash of the previous block (parent hash)
/// `A` Smart contract address
/// `D` Digest of the values
/// `M` Storage slot of the mapping
/// `S` Storage slot of the variable holding the length
/// `C` Merkle root of the storage database

const H_LEN: usize = PACKED_HASH_LEN;
const N_LEN: usize = 1;
const PREV_H_LEN: usize = PACKED_HASH_LEN;
const A_LEN: usize = PACKED_ADDRESS_LEN;
const D_LEN: usize = CURVE_TARGET_LEN;
const M_LEN: usize = 1;
const S_LEN: usize = 1;
const C_LEN: usize = NUM_HASH_OUT_ELTS;
const TOTAL_LEN: usize = H_LEN + N_LEN + PREV_H_LEN + A_LEN + D_LEN + M_LEN + S_LEN + C_LEN;

const H_IDX: usize = 0;
const N_IDX: usize = H_IDX + H_LEN;
const PREV_H_IDX: usize = N_IDX + N_LEN;
const A_IDX: usize = PREV_H_IDX + PREV_H_LEN;
const D_IDX: usize = A_IDX + A_LEN;
const M_IDX: usize = D_IDX + D_LEN;
const S_IDX: usize = M_IDX + M_LEN;
const C_IDX: usize = S_IDX + S_LEN;

#[derive(Clone)]
pub struct BlockLinkingInputs<'a, T: Clone> {
    pub(crate) inner: &'a [T],
}

impl<'a, T: Clone> BlockLinkingInputs<'a, T> {
    pub fn register<
        F,
        const D: usize,
        const DEPTH: usize,
        const NODE_LEN: usize,
        const BLOCK_LEN: usize,
    >(
        cb: &mut CircuitBuilder<F, D>,
        wires: &BlockLinkingWires<DEPTH, NODE_LEN, BLOCK_LEN>,
        storage_inputs: &StorageInputs<Target>,
    ) where
        F: RichField + Extendable<D>,
        [(); PAD_LEN(NODE_LEN)]:,
        [(); PAD_LEN(BLOCK_LEN)]:,
        [(); DEPTH - 1]:,
    {
        wires
            .block_inputs
            .hash
            .output_array
            .register_as_public_input(cb);
        cb.register_public_input(wires.block_inputs.number.0);
        wires.block_inputs.parent_hash.register_as_public_input(cb);
        wires
            .account_inputs
            .contract_address
            .convert_u8_to_u32(cb) // always register the packed version
            .register_as_public_input(cb);
        // Register the curve point of digest (avoid F must be GoldilocksField).
        let digest_data = storage_inputs.digest_data();
        cb.register_public_inputs(&digest_data.0);
        cb.register_public_inputs(&digest_data.1);
        cb.register_public_input(digest_data.2);
        cb.register_public_input(storage_inputs.mapping_slot());
        cb.register_public_input(storage_inputs.length_slot());

        // Only expose the equivalent storage tree root here, NOT the one from
        // blockchain.
        cb.register_public_inputs(storage_inputs.merkle_root_data());
    }

    /// Creates a representation of the public inputs from the provided slice.
    ///
    /// # Panics
    ///
    /// This function will panic if the length of the provided slice is smaller than
    /// [Self::TOTAL_LEN].
    pub fn from_slice(arr: &'a [T]) -> Self {
        assert!(
            TOTAL_LEN <= arr.len(),
            "The public inputs slice length must be equal or greater than the expected length."
        );

        Self { inner: arr }
    }

    pub fn block_hash(&self) -> &[T] {
        &self.inner[H_IDX..N_IDX]
    }

    pub fn block_number(&self) -> &T {
        &self.inner[N_IDX]
    }

    pub fn prev_block_hash(&self) -> &[T] {
        &self.inner[PREV_H_IDX..A_IDX]
    }

    pub fn packed_address(&self) -> &[T] {
        &self.inner[A_IDX..D_IDX]
    }

    pub fn digest(&self) -> &[T] {
        &self.inner[D_IDX..M_IDX]
    }

    pub fn mapping_slot(&self) -> &T {
        &self.inner[M_IDX]
    }

    pub fn length_slot(&self) -> &T {
        &self.inner[S_IDX]
    }

    pub fn merkle_root(&self) -> &[T] {
        &self.inner[C_IDX..]
    }
}

#[cfg(test)]
mod tests {
    use std::array;

    use rand::{rngs::StdRng, Rng, RngCore, SeedableRng};

    use super::*;

    impl<'a, T: Clone> BlockLinkingInputs<'a, T> {
        pub const TOTAL_LEN: usize = TOTAL_LEN;
    }

    impl<'a, T: Copy + Default> BlockLinkingInputs<'a, T> {
        /// Writes the parts of the block liking public inputs into the provided target array.
        #[allow(clippy::too_many_arguments)]
        pub fn parts_into_values(
            values: &mut [T; TOTAL_LEN],
            h: &[T; N_IDX - H_IDX],
            n: &[T; PREV_H_IDX - N_IDX],
            prev_h: &[T; A_IDX - PREV_H_IDX],
            a: &[T; D_IDX - A_IDX],
            d: &[T; M_IDX - D_IDX],
            m: T,
            s: T,
            c: &[T; TOTAL_LEN - C_IDX],
        ) {
            values[H_IDX..N_IDX].copy_from_slice(h);
            values[N_IDX..PREV_H_IDX].copy_from_slice(n);
            values[PREV_H_IDX..A_IDX].copy_from_slice(prev_h);
            values[A_IDX..D_IDX].copy_from_slice(a);
            values[D_IDX..M_IDX].copy_from_slice(d);
            values[M_IDX] = m;
            values[S_IDX] = s;
            values[C_IDX..TOTAL_LEN].copy_from_slice(c);
        }
    }

    impl<'a, F: RichField> BlockLinkingInputs<'a, F> {
        pub fn values_from_seed(seed: u64) -> [F; TOTAL_LEN] {
            let rng = &mut StdRng::seed_from_u64(seed);

            let h = array::from_fn(|_| F::from_canonical_u32(rng.next_u32()));
            let n = array::from_fn(|_| F::from_canonical_u32(rng.next_u32()));
            let prev_h = array::from_fn(|_| F::from_canonical_u32(rng.next_u32()));
            let a = array::from_fn(|_| F::from_canonical_u32(rng.next_u32()));
            let d = array::from_fn(|_| F::from_canonical_u32(rng.next_u32()));
            let m = F::from_canonical_u8(rng.gen::<u8>());
            let s = F::from_canonical_u8(rng.gen::<u8>());
            let c = array::from_fn(|_| F::from_canonical_u32(rng.next_u32()));

            let mut values = array::from_fn(|_| F::ZERO);
            Self::parts_into_values(&mut values, &h, &n, &prev_h, &a, &d, m, s, &c);

            values
        }
    }
}
