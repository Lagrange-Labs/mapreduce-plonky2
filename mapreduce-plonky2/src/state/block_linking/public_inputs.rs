//! Public inputs generated by this circuit

use super::BlockLinkingWires;
use crate::mpt_sequential::PAD_LEN;
use plonky2::{
    field::extension::Extendable, hash::hash_types::RichField,
    plonk::circuit_builder::CircuitBuilder,
};

/// This is a wrapper around an array of targets set as public inputs of any
/// proof generated in this module. They all share the same structure.
/// `H` Block header hash
/// `N` Block number
/// `PREV_H` Header hash of the previous block (parent hash)
/// `A` Smart contract address
/// `D` Digest of the values
/// `M` Storage slot of the mapping
/// `S` Storage slot of the variable holding the length
/// `C` Merkle root of the storage database
/// H = 8, N = 2, PREV_H = 8, A = 5, D = 5*2+1, M = 8, S = 1, C = 8
const H_IDX: usize = 0;
const N_IDX: usize = 8;
const PREV_H_IDX: usize = 10;
const A_IDX: usize = 18;
const D_IDX: usize = 23;
const M_IDX: usize = 34;
const S_IDX: usize = 42;
const C_IDX: usize = 43;
const TOTAL_LEN: usize = 51;

pub struct PublicInputs<T> {
    inner: [T; TOTAL_LEN],
}

impl<T> PublicInputs<T> {
    pub fn register<
        F,
        const D: usize,
        const DEPTH: usize,
        const NODE_LEN: usize,
        const BLOCK_LEN: usize,
    >(
        cb: &mut CircuitBuilder<F, D>,
        wires: &BlockLinkingWires<DEPTH, NODE_LEN, BLOCK_LEN>,
    ) where
        F: RichField + Extendable<D>,
        [(); PAD_LEN(NODE_LEN)]:,
        [(); PAD_LEN(BLOCK_LEN)]:,
        [(); DEPTH - 1]:,
    {
        wires.block_inputs.hash.output.register_as_public_input(cb);
        wires.block_inputs.number.register_as_public_input(cb);
        wires.block_inputs.parent_hash.register_as_public_input(cb);
        cb.register_public_inputs(wires.storage_proof.a());
        cb.register_public_inputs(wires.storage_proof.d());
        cb.register_public_inputs(wires.storage_proof.m());
        cb.register_public_inputs(wires.storage_proof.s());

        // Only expose the equivalent storage tree root here, NOT the one from
        // blockchain.
        cb.register_public_inputs(wires.storage_proof.merkle_root());
    }

    pub fn block_hash(&self) -> &[T] {
        &self.inner[H_IDX..N_IDX]
    }

    pub fn block_number(&self) -> &[T] {
        &self.inner[N_IDX..PREV_H_IDX]
    }

    pub fn prev_block_hash(&self) -> &[T] {
        &self.inner[PREV_H_IDX..A_IDX]
    }

    pub fn a(&self) -> &[T] {
        &self.inner[A_IDX..D_IDX]
    }

    pub fn d(&self) -> &[T] {
        &self.inner[D_IDX..M_IDX]
    }

    pub fn m(&self) -> &[T] {
        &self.inner[M_IDX..S_IDX]
    }

    pub fn s(&self) -> &[T] {
        &self.inner[S_IDX..C_IDX]
    }

    pub fn merkle_root(&self) -> &[T] {
        &self.inner[C_IDX..]
    }
}
