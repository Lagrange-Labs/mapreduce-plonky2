//! Public inputs generated by this circuit

use super::BlockLinkingWires;
use crate::{mpt_sequential::PAD_LEN, storage::PublicInputs as StorageInputs};
use plonky2::{
    field::extension::Extendable, hash::hash_types::RichField, iop::target::Target,
    plonk::circuit_builder::CircuitBuilder,
};

pub struct PublicInputs<T> {
    inner: [T; PublicInputs::<()>::TOTAL_LEN],
}

impl<T> PublicInputs<T> {
    /// This is a wrapper around an array of targets set as public inputs of any
    /// proof generated in this module. They all share the same structure.
    /// `H` Block header hash
    /// `N` Block number
    /// `PREV_H` Header hash of the previous block (parent hash)
    /// `A` Smart contract address
    /// `D` Digest of the values
    /// `M` Storage slot of the mapping
    /// `S` Storage slot of the variable holding the length
    /// `C` Merkle root of the storage database
    /// H = 8, N = 2, PREV_H = 8, A = 5, D = 5*2+1, M = 8, S = 1, C = 8
    pub const H_LEN: usize = 8;
    pub const N_LEN: usize = 2;
    pub const PREV_H_LEN: usize = 8;
    pub const A_LEN: usize = 5;
    pub const D_LEN: usize = 11;
    pub const M_LEN: usize = 8;
    pub const S_LEN: usize = 1;
    pub const C_LEN: usize = 8;
    pub const TOTAL_LEN: usize = 51;

    pub const H_IDX: usize = 0;
    pub const N_IDX: usize = Self::H_IDX + Self::H_LEN;
    pub const PREV_H_IDX: usize = Self::N_IDX + Self::N_LEN;
    pub const A_IDX: usize = Self::PREV_H_IDX + Self::PREV_H_LEN;
    pub const D_IDX: usize = Self::A_IDX + Self::A_LEN;
    pub const M_IDX: usize = Self::D_IDX + Self::D_LEN;
    pub const S_IDX: usize = Self::M_IDX + Self::M_LEN;
    pub const C_IDX: usize = Self::S_IDX + Self::S_LEN;

    pub fn register<
        F,
        const D: usize,
        const DEPTH: usize,
        const NODE_LEN: usize,
        const BLOCK_LEN: usize,
    >(
        cb: &mut CircuitBuilder<F, D>,
        wires: &BlockLinkingWires<DEPTH, NODE_LEN, BLOCK_LEN>,
        storage_inputs: &StorageInputs<Target>,
    ) where
        F: RichField + Extendable<D>,
        [(); PAD_LEN(NODE_LEN)]:,
        [(); PAD_LEN(BLOCK_LEN)]:,
        [(); DEPTH - 1]:,
    {
        wires
            .block_inputs
            .hash
            .output_array
            .register_as_public_input(cb);
        cb.register_public_input(wires.block_inputs.number.0);
        wires.block_inputs.parent_hash.register_as_public_input(cb);
        cb.register_public_inputs(storage_inputs.contract_address_data());
        // Register the curve point of digest (avoid F must be GoldilocksField).
        let digest_data = storage_inputs.digest_data();
        cb.register_public_inputs(&digest_data.0);
        cb.register_public_inputs(&digest_data.1);
        cb.register_public_input(digest_data.2);
        cb.register_public_input(storage_inputs.mapping_slot());
        cb.register_public_input(storage_inputs.length_slot());

        // Only expose the equivalent storage tree root here, NOT the one from
        // blockchain.
        cb.register_public_inputs(storage_inputs.merkle_root_data());
    }

    pub fn inner(&self) -> &[T] {
        &self.inner
    }

    pub fn block_hash(s: &[T]) -> &[T] {
        &s[Self::H_IDX..Self::N_IDX]
    }

    pub fn block_number(s: &[T]) -> &[T] {
        &s[Self::N_IDX..Self::PREV_H_IDX]
    }

    pub fn prev_block_hash(s: &[T]) -> &[T] {
        &s[Self::PREV_H_IDX..Self::A_IDX]
    }

    pub fn a(s: &[T]) -> &[T] {
        &s[Self::A_IDX..Self::D_IDX]
    }

    pub fn d(s: &[T]) -> &[T] {
        &s[Self::D_IDX..Self::M_IDX]
    }

    pub fn m(s: &[T]) -> &[T] {
        &s[Self::M_IDX..Self::S_IDX]
    }

    pub fn s(s: &[T]) -> &[T] {
        &s[Self::S_IDX..Self::C_IDX]
    }

    pub fn merkle_root(s: &[T]) -> &[T] {
        &s[Self::C_IDX..]
    }
}
