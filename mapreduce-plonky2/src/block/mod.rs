//! This circuit proves the correct updating of the block tree. There're steps
//! on how to prove the correct construction:
//! - Prove the sequentiality property of the last block inserted.
//! - Prove we include the new block right after the previous block inserted.
//! - Prove the append-only property, that we keep appending blocks without
//!   deletion and modification.

mod public_inputs;

use crate::state::PublicInputs as LeafInputs;
use plonky2::{
    field::extension::Extendable,
    hash::{
        hash_types::{HashOut, HashOutTarget, RichField, NUM_HASH_OUT_ELTS},
        poseidon::PoseidonHash,
    },
    iop::{
        target::{BoolTarget, Target},
        witness::{PartialWitness, WitnessWrite},
    },
    plonk::circuit_builder::CircuitBuilder,
};
use plonky2_crypto::u32::arithmetic_u32::CircuitBuilderU32;
use public_inputs::PublicInputs;
use std::array;

/// Block tree wires
pub struct BlockTreeWires<const DEPTH: usize> {
    /// Path from the previous leaf to the new root, it's not a connected path
    /// in the tree, it starts from the previous leaf and includes each
    /// intermidiate node per level till to the root. These nodes act as left
    /// children which are used to calculate and prove the sequential hashes
    /// from leaf to root.
    path: [HashOutTarget; DEPTH],
    /// Previous leaf sibling
    prev_sibling: HashOutTarget,
    /// The flag identified if the previous leaf is dummy (current is the first)
    is_prev_dummy: BoolTarget,
    /// The flag identified if the previous leaf is sibling of the current
    is_direct_sibling: BoolTarget,
}

/// Block tree circuit used to prove the correct updating of the block tree
#[derive(Clone, Debug)]
pub struct BlockTreeCircuit<F, const DEPTH: usize>
where
    F: RichField,
{
    /// Path from the previous leaf to the new root, it's not a connected path
    /// in the tree, it starts from the previous leaf and includes each
    /// intermidiate node per level till to the root. These nodes act as left
    /// children which are used to calculate and prove the sequential hashes
    /// from leaf to root.
    path: [HashOut<F>; DEPTH],
    /// Previous leaf sibling
    prev_sibling: HashOut<F>,
    /// The flag identified if the previous leaf is dummy (current is the first)
    is_prev_dummy: bool,
    /// The flag identified if the previous leaf is sibling of the current
    is_direct_sibling: bool,
}

impl<F, const DEPTH: usize> BlockTreeCircuit<F, DEPTH>
where
    F: RichField,
{
    pub fn new(
        path: [HashOut<F>; DEPTH],
        prev_sibling: HashOut<F>,
        is_prev_dummy: bool,
        is_direct_sibling: bool,
    ) -> Self {
        Self {
            path,
            prev_sibling,
            is_prev_dummy,
            is_direct_sibling,
        }
    }

    /// Build for circuit.
    pub fn build<const D: usize>(
        cb: &mut CircuitBuilder<F, D>,
        // Previous block public inputs (generated by this circuit)
        prev_pi: &[Target],
        // Previous block tree leaf (state root public inputs)
        prev_leaf_pi: &[Target],
        // New block tree leaf (state root public inputs)
        new_leaf_pi: &[Target],
    ) -> BlockTreeWires<DEPTH>
    where
        F: Extendable<D>,
    {
        // Wrap the public inputs.
        let prev_pi = PublicInputs::from(prev_pi);
        let prev_leaf_pi = LeafInputs::from(prev_leaf_pi);
        let new_leaf_pi = LeafInputs::from(new_leaf_pi);

        // Initialize the targets in wires.
        let path = array::from_fn(|_| cb.add_virtual_hash());
        let prev_sibling = cb.add_virtual_hash();
        let [is_prev_dummy, is_direct_sibling] = [0, 1].map(|_| cb.add_virtual_bool_target_safe());

        // Verify the previous block proof.
        verify_previous_proof(cb, &prev_pi, &prev_leaf_pi, &new_leaf_pi, is_prev_dummy);

        // Verify the previous leaf proof with path.
        verify_sequentiality(cb, &prev_leaf_pi, &path, &prev_sibling, is_direct_sibling);

        // Verify both the previous and new root of this block tree which are
        // calculated from the leaves sequentially.
        verify_append_only(cb, &prev_pi, &new_leaf_pi, &path, is_direct_sibling);

        let wires = BlockTreeWires {
            path,
            prev_sibling,
            is_prev_dummy,
            is_direct_sibling,
        };

        // Register the public inputs.
        PublicInputs::register(
            cb,
            &prev_pi.init_root(),
            path.last().unwrap(),
            prev_pi.first_block_number(),
            new_leaf_pi.block_number(),
            &new_leaf_pi.block_header(),
        );

        wires
    }

    /// Assign the wires.
    pub fn assign(&self, pw: &mut PartialWitness<F>, wires: &BlockTreeWires<DEPTH>) {
        wires
            .path
            .into_iter()
            .zip(self.path)
            .for_each(|(t, v)| pw.set_hash_target(t, v));
        pw.set_hash_target(wires.prev_sibling, self.prev_sibling);
        [
            (wires.is_prev_dummy, self.is_prev_dummy),
            (wires.is_direct_sibling, self.is_direct_sibling),
        ]
        .into_iter()
        .for_each(|(t, v)| pw.set_bool_target(t, v));
    }
}

/// Verify the previous proof.
fn verify_previous_proof<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
    prev_pi: &PublicInputs<Target>,
    prev_leaf_pi: &LeafInputs<Target>,
    new_leaf_pi: &LeafInputs<Target>,
    is_prev_dummy: BoolTarget,
) {
    // Verify the previous block proof with previous leaf proof.
    cb.connect_u32(prev_pi.new_block_number(), prev_leaf_pi.block_number());
    let prev_block_header = prev_pi.block_header();
    prev_block_header.enforce_equal(cb, &prev_leaf_pi.block_header());

    // Verify prev_block_number + 1 == new_block_number.
    let one = cb.one_u32();
    let (exp_block_number, overflow) = cb.add_u32(prev_leaf_pi.block_number(), one);
    cb.assert_zero_u32(overflow);
    let new_block_number = new_leaf_pi.block_number();
    cb.connect_u32(exp_block_number, new_block_number);

    // Verify prev_block_header = new_block.prev_block_header.
    prev_block_header.enforce_equal(cb, &new_leaf_pi.prev_block_header());

    // Check that z_0 is set accordingly to the current block number if this is
    // the proof for the first block being inserted to the block tree.
    let first_block_number = prev_pi.first_block_number();
    let exp_first_block_number = cb.select(is_prev_dummy, new_block_number.0, first_block_number.0);
    cb.connect(exp_first_block_number, first_block_number.0);
}

/// Verify the previous leaf proof with path.
fn verify_sequentiality<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
    prev_leaf_pi: &LeafInputs<Target>,
    path: &[HashOutTarget],
    prev_sibling: &HashOutTarget,
    is_direct_sibling: BoolTarget,
) {
    let prev_leaf = leaf_hash(cb, prev_leaf_pi);

    // prev_parent = hash([prev_sibling, prev_leaf])
    let data_to_hash: Vec<_> = prev_sibling
        .elements
        .into_iter()
        .chain(prev_leaf.elements)
        .collect();
    let prev_parent = cb.hash_n_to_hash_no_pad::<PoseidonHash>(data_to_hash);

    // If is_direct_sibling, check prev_leaf == path[0], else
    // prev_parent == path[1].
    let lhs = select_hash(cb, is_direct_sibling, prev_leaf, prev_parent);
    let rhs = select_hash(cb, is_direct_sibling, path[0], path[1]);
    cb.connect_hashes(lhs, rhs);
}

/// Verify both the previous and new root of this block tree which are
/// calculated from the leaves sequentially.
fn verify_append_only<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
    prev_pi: &PublicInputs<Target>,
    new_leaf: &LeafInputs<Target>,
    path: &[HashOutTarget],
    is_direct_sibling: BoolTarget,
) {
    let leaf_hash = leaf_hash(cb, new_leaf);

    let prev_root = prev_pi.new_root();
    let (new_root, path_without_root) = path.split_last().unwrap();

    // Verify the path from empty leaf to the previous root.
    let empty_hash = empty_hash(cb);
    verify_path(
        cb,
        &empty_hash,
        &prev_root,
        path_without_root,
        is_direct_sibling,
    );

    // Verify the path from the new leaf to the root.
    verify_path(
        cb,
        &leaf_hash,
        new_root,
        path_without_root,
        is_direct_sibling,
    );
}

/// Verify the path from leaf to root.
fn verify_path<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
    leaf: &HashOutTarget,
    root: &HashOutTarget,
    path: &[HashOutTarget],
    is_direct_sibling: BoolTarget,
) {
    // If is_direct_sibling, hash(path[0], leaf), else hash(leaf, empty).
    let empty_hash = empty_hash(cb);
    let lhs = select_hash(cb, is_direct_sibling, path[0], *leaf);
    let rhs = select_hash(cb, is_direct_sibling, *leaf, empty_hash);
    let data_to_hash = lhs.elements.into_iter().chain(rhs.elements).collect();
    let init = cb.hash_n_to_hash_no_pad::<PoseidonHash>(data_to_hash);

    // hash(p[i], hash(p[i - 1, ... hash(p[1], init) ...)
    let exp_root = path[1..].iter().fold(init, |acc, p| {
        let data_to_hash = p.elements.into_iter().chain(acc.elements).collect();
        cb.hash_n_to_hash_no_pad::<PoseidonHash>(data_to_hash)
    });

    cb.connect_hashes(exp_root, *root);
}

/// Calculate the leaf hash.
fn leaf_hash<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
    leaf: &LeafInputs<Target>,
) -> HashOutTarget {
    let state_root = leaf.root().elements;
    let block_number = leaf.block_number().0;
    let block_header = leaf.block_header().arr.map(|u32_target| u32_target.0);

    // hash([state_root, block_number, block_header])
    // TODO: Is it necesssary to convert all to u8 targets?
    let data_to_hash: Vec<_> = state_root
        .into_iter()
        .chain([block_number])
        .chain(block_header)
        .collect();

    cb.hash_n_to_hash_no_pad::<PoseidonHash>(data_to_hash)
}

/// Return an empty hash.
fn empty_hash<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
) -> HashOutTarget {
    let zero = cb.zero();
    HashOutTarget {
        elements: [zero; NUM_HASH_OUT_ELTS],
    }
}

/// If b is true return x, otherwise return y.
fn select_hash<F: RichField + Extendable<D>, const D: usize>(
    cb: &mut CircuitBuilder<F, D>,
    b: BoolTarget,
    x: HashOutTarget,
    y: HashOutTarget,
) -> HashOutTarget {
    HashOutTarget::from_vec(
        x.elements
            .into_iter()
            .zip(y.elements)
            .map(|(x_element, y_element)| cb.select(b, x_element, y_element))
            .collect(),
    )
}
