use anyhow::Result;
use recursion_framework::{
    circuit_builder::public_input_targets,
    framework::{
        RecursiveCircuits, RecursiveCircuitsVerifierGagdet, RecursiveCircuitsVerifierTarget,
    },
    serialization::{deserialize, serialize},
};
use serde::{Deserialize, Serialize};
use std::array::from_fn as create_array;

use plonky2::{
    hash::{
        hash_types::{HashOut, HashOutTarget, NUM_HASH_OUT_ELTS},
        poseidon::PoseidonHash,
    },
    iop::{target::Target, witness::PartialWitness},
    plonk::{
        circuit_builder::CircuitBuilder,
        circuit_data::{CircuitData, VerifierCircuitData},
        config::Hasher,
        proof::ProofWithPublicInputs,
    },
};
use plonky2_crypto::u32::arithmetic_u32::U32Target;

use crate::{
    api::{default_config, mapping, serialize_proof, ProofWithVK, C, D, F},
    eth::left_pad32,
    keccak::OutputHash,
    query2::block,
    types::{PackedAddressTarget, CURVE_TARGET_LEN, MAPPING_KEY_LEN, PACKED_MAPPING_KEY_LEN},
    utils::convert_u8_to_u32_slice,
    verifier_gadget::VerifierTarget,
};

pub use self::circuit::RevelationCircuit;
use self::circuit::RevelationWires;

pub mod circuit;
mod public_inputs;
pub use self::public_inputs::RevelationPublicInputs;
/// Wires containing the main logic wires of the RevelationCircuit,
/// the verifier wires to check a crate::block proof (block db) and
/// the verifier wires to check a proof from query2/block circuit set.
/// The two const parameters are:
/// - `BLOCK_DB_DEPTH` the depth of the block db merkle tree, fixed since we
///   we use a fixed sparse merkle tree.
/// - `L` the number of NFT IDs to reveal
#[derive(Serialize, Deserialize)]
pub struct Parameters<const BLOCK_DB_DEPTH: usize, const L: usize> {
    /// The regular wires for the logic of RevelationCircuit
    revelation: RevelationWires<L>,
    /// The wires to verify a proof in the query2/block circuit set
    query2_block: RecursiveCircuitsVerifierTarget<D>,
    /// The actual set of potential proofs VK that can be generated by query2/block
    query2_block_circuit_set: RecursiveCircuits<F, C, D>,
    /// The wires to verify a single regular proof by crate::block module
    block_db: VerifierTarget<D>,
    /// The circuit data of the revelation circuit, required to generate and verify
    /// a revelation proof.
    #[serde(serialize_with = "serialize", deserialize_with = "deserialize")]
    circuit_data: CircuitData<F, C, D>,
}

/// Circuit inputs for the revelation step which contains the
/// raw witnesses and the proof to verify in circuit.
/// The proof is any of the proofs contained in the `query2/block/` module.
struct RevelationRecursiveInput<const L: usize> {
    /// values expected by the RevelationCircuit main logic
    logic_inputs: RevelationCircuit<L>,
    /// The actual proof generated by query2/block module, the top one
    query2_block_proof: ProofWithVK,
    /// The actual proof generated by the block db module, each time a new block
    /// is preprocessed
    block_db_proof: ProofWithVK,
}

impl<const L: usize> RevelationRecursiveInput<L> {
    pub fn new(
        mapping_keys: Vec<Vec<u8>>,
        query_min_block: usize,
        query_max_block: usize,
        query2_block_proof: Vec<u8>,
        block_db_proof: Vec<u8>,
    ) -> Result<RevelationRecursiveInput<L>> {
        let keys = create_array(|i| {
            if i < mapping_keys.len() {
                let padded = left_pad32(&mapping_keys[i]);
                let packed = convert_u8_to_u32_slice(&padded);
                create_array(|j| packed[j])
            } else {
                [0u32; PACKED_MAPPING_KEY_LEN]
            }
        });
        let num_entries = mapping_keys.len();
        assert!(
            num_entries <= L,
            "Number of entries {} should not exceed fixed parameter L {}",
            num_entries,
            L
        );
        let main_inputs = RevelationCircuit {
            packed_keys: keys,
            num_entries: num_entries as u8,
            query_min_block_number: query_min_block,
            query_max_block_number: query_max_block,
        };
        Ok(RevelationRecursiveInput {
            logic_inputs: main_inputs,
            query2_block_proof: ProofWithVK::deserialize(&query2_block_proof)?,
            block_db_proof: ProofWithVK::deserialize(&block_db_proof)?,
        })
    }
}

pub const fn NUM_QUERY2_IO<const L: usize>() -> usize {
    RevelationPublicInputs::<(), L>::total_len()
}

impl<const BLOCK_DB_DEPTH: usize, const L: usize> Parameters<BLOCK_DB_DEPTH, L> {
    pub fn build(
        query2_block_set: &RecursiveCircuits<F, C, D>,
        block_db_vk: VerifierCircuitData<F, C, D>,
    ) -> Self
    where
        [(); NUM_QUERY2_IO::<L>()]:,
        [(); <PoseidonHash as Hasher<F>>::HASH_SIZE]:,
    {
        let mut b = CircuitBuilder::new(default_config());
        // instantiate the wires to verify a query2/block proof which can be in a circuit set
        let query2_block_verifier_gadget =
            RecursiveCircuitsVerifierGagdet::<F, C, D, { NUM_QUERY2_IO::<L>() }>::new(
                default_config(),
                query2_block_set,
            );
        let query2_block_verifier_wires =
            query2_block_verifier_gadget.verify_proof_in_circuit_set(&mut b);
        let query2_block_pi = block::BlockPublicInputs::<Target>::from(
            query2_block_verifier_wires.get_public_input_targets::<F, { NUM_QUERY2_IO::<L>() }>(),
        );

        assert_eq!(query2_block_pi.inputs.len(), NUM_QUERY2_IO::<L>());
        // instantiate the wires to verify a block db proof, which only has a single vk, no set
        let block_db_wires = VerifierTarget::verify_proof(&mut b, &block_db_vk);
        let block_db_pi =
            crate::block::PublicInputs::from(&block_db_wires.get_proof().public_inputs);

        let wires =
            RevelationCircuit::build::<BLOCK_DB_DEPTH>(&mut b, block_db_pi, query2_block_pi);

        let circuit_data = b.build::<C>();
        Self {
            revelation: wires,
            query2_block: query2_block_verifier_wires,
            query2_block_circuit_set: query2_block_set.clone(),
            block_db: block_db_wires,
            circuit_data,
        }
    }
    fn generate_proof_internal(
        &self,
        inputs: RevelationRecursiveInput<L>,
    ) -> Result<ProofWithPublicInputs<F, C, D>>
    where
        [(); <PoseidonHash as Hasher<F>>::HASH_SIZE]:,
    {
        let mut pw = PartialWitness::new();
        // assigns the block db proof, simple verifier target
        let (proof, vd) = inputs.block_db_proof.into();
        self.block_db.set_target(&mut pw, &proof, &vd);
        // assigns the query2/block proof, recursive verifier target
        let (proof, vd) = inputs.query2_block_proof.into();
        self.query2_block
            .set_target(&mut pw, &self.query2_block_circuit_set, &proof, &vd)?;
        // assigns the regular wires
        inputs.logic_inputs.assign(&mut pw, &self.revelation);
        let proof = self.circuit_data.prove(pw)?;
        Ok(proof)
    }

    pub fn generate_proof(&self, inputs: RevelationRecursiveInput<L>) -> Result<Vec<u8>> {
        let proof = self.generate_proof_internal(inputs)?;
        serialize_proof(&proof)
    }
    pub fn verifier_data(&self) -> VerifierCircuitData<F, C, D> {
        self.circuit_data.verifier_data()
    }
}
