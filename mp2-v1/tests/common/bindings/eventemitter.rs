/**

Generated by the following Solidity interface...
```solidity
interface EventEmitter {
    event noIOneD(uint256 num);
    event noITwoD(uint256 num, uint256 numTwo);
    event noIndexed();
    event oneData(uint256 indexed num, uint256 indexed numTwo, uint256 indexed numThree, uint256 numFour);
    event oneIOneD(uint256 indexed num, uint256 numTwo);
    event oneITwoD(uint256 indexed num, uint256 numTwo, uint256 numThree);
    event oneIndexed(uint256 indexed num);
    event threeIndexed(uint256 indexed num, uint256 indexed numTwo, uint256 indexed numThree);
    event twoData(uint256 indexed num, uint256 indexed numTwo, uint256 indexed numThree, uint256 numFour, uint256 numFive);
    event twoIOneD(uint256 indexed num, uint256 indexed numTwo, uint256 numThree);
    event twoITwoD(uint256 indexed num, uint256 indexed numTwo, uint256 numThree, uint256 numFour);
    event twoIndexed(uint256 indexed num, uint256 indexed numTwo);

    function increment() external;
    function number() external view returns (uint256);
    function testNoIOneD() external;
    function testNoITwoD() external;
    function testNoIndexed() external;
    function testOneData() external;
    function testOneIOneD() external;
    function testOneITwoD() external;
    function testOneIndexed() external;
    function testThreeIndexed() external;
    function testTwoData() external;
    function testTwoIOneD() external;
    function testTwoITwoD() external;
    function testTwoIndexed() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "increment",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "number",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "testNoIOneD",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testNoITwoD",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testNoIndexed",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testOneData",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testOneIOneD",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testOneITwoD",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testOneIndexed",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testThreeIndexed",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testTwoData",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testTwoIOneD",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testTwoITwoD",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "testTwoIndexed",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "noIOneD",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "noITwoD",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "noIndexed",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "oneData",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numThree",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numFour",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "oneIOneD",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "oneITwoD",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "numThree",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "oneIndexed",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "threeIndexed",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numThree",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "twoData",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numThree",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numFour",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "numFive",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "twoIOneD",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numThree",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "twoITwoD",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numThree",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "numFour",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "twoIndexed",
    "inputs": [
      {
        "name": "num",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "numTwo",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod EventEmitter {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b5061057e8061001d5f395ff3fe608060405234801561000f575f80fd5b50600436106100e3575f3560e01c806346d6a7b5116100885780638381f58a116100635780638381f58a14610139578063b1e057a914610153578063c02420001461015b578063d09de08a14610163575f80fd5b806346d6a7b51461012157806363eb70f014610129578063729d452014610131575f80fd5b806331c1c63b116100c357806331c1c63b14610101578063338b538a146101095780634282ed58146101115780634369f72814610119575f80fd5b80623c7e56146100e7578062d83b55146100f15780632dc34764146100f9575b5f80fd5b6100ef61016b565b005b6100ef6101cf565b6100ef61022b565b6100ef610295565b6100ef6102e2565b6100ef610322565b6100ef61034b565b6100ef610387565b6100ef6103d7565b6100ef61042c565b6101415f5481565b60405190815260200160405180910390f35b6100ef61045f565b6100ef6104bc565b6100ef6104ee565b5f54610178906002610517565b5f54610185906001610517565b5f547ff57f433eb9493cf4d9cb5763c12221d9b095804644d4ee006a78c72076cff9476101b3826003610517565b6040519081526020015b60405180910390a46101cd6104ee565b565b5f547fef4c88193498df237f039055d1212ac2a3b93ed8aea88c814312e50f6a32592d6101fd826001610517565b5f5461020a906002610517565b604080519283526020830191909152015b60405180910390a26101cd6104ee565b5f54610238906002610517565b5f54610245906001610517565b5f547ff03d29753fbd5ac209bab88a99b396bcc25c3e72530d02c81aea4d324ab3d742610273826003610517565b5f54610280906004610517565b604080519283526020830191909152016101bd565b5f546102a2906002610517565b5f546102af906001610517565b5f805460405190917f1d18de2cd8798a1c29b9255930c807eb6c84ae0acb2219acbb11e0f65cf813e991a46101cd6104ee565b5f546102ef906001610517565b5f805460405190917fa6baf14d8f11d7a4497089bb3fca0adfc34837cfb1f4aa370634d36ef0305b4691a36101cd6104ee565b6040517ef7c74f0533aa15e5ac7cafa9f9261d14da1e78830deba7110fbc79001ed15e905f90a1565b5f547f168718c0b1eb6bfd7b0edecea5c6fc6502737ad73a4c9f52ffa7e553c8eb9f53610379826001610517565b60405190815260200161021b565b5f547f2fa61517ddf9dc7f2f3d5ca72414a01c834d9c5bb7c336c977423c85094bba61906103b6816001610517565b604080519283526020830191909152015b60405180910390a16101cd6104ee565b5f546103e4906001610517565b5f547f3bb2d6337882faa5526cf806c9763904a90f3363590dd4386913e3fcd8a2e1d1610412826002610517565b6040519081526020015b60405180910390a36101cd6104ee565b5f805460405190917fc2809a1a2fb95d84cfdc488cdb320a144c158f8d44836c9c2d4badba082bfdfa91a26101cd6104ee565b5f5461046c906001610517565b5f547f4b92229abe204a30d7b088d8110291760934d65b3c960680ad94e05f52a8860561049a826002610517565b5f546104a7906003610517565b6040805192835260208301919091520161041c565b7f04f7fb289e51ea9996ec98e62ff4b651becfa6e53f3b850be209b69741c66f245f546040516103c791815260200190565b5f805490806104fc83610530565b9190505550565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561052a5761052a610503565b92915050565b5f6001820161054157610541610503565b506001019056fea2646970667358221220b4cc2df5eed06f538a31157edfaeeee591a5719d35fb47f3b6ce5d31c1ffe2f964736f6c63430008180033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[Pa\x05~\x80a\0\x1D_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\xE3W_5`\xE0\x1C\x80cF\xD6\xA7\xB5\x11a\0\x88W\x80c\x83\x81\xF5\x8A\x11a\0cW\x80c\x83\x81\xF5\x8A\x14a\x019W\x80c\xB1\xE0W\xA9\x14a\x01SW\x80c\xC0$ \0\x14a\x01[W\x80c\xD0\x9D\xE0\x8A\x14a\x01cW_\x80\xFD[\x80cF\xD6\xA7\xB5\x14a\x01!W\x80cc\xEBp\xF0\x14a\x01)W\x80cr\x9DE \x14a\x011W_\x80\xFD[\x80c1\xC1\xC6;\x11a\0\xC3W\x80c1\xC1\xC6;\x14a\x01\x01W\x80c3\x8BS\x8A\x14a\x01\tW\x80cB\x82\xEDX\x14a\x01\x11W\x80cCi\xF7(\x14a\x01\x19W_\x80\xFD[\x80b<~V\x14a\0\xE7W\x80b\xD8;U\x14a\0\xF1W\x80c-\xC3Gd\x14a\0\xF9W[_\x80\xFD[a\0\xEFa\x01kV[\0[a\0\xEFa\x01\xCFV[a\0\xEFa\x02+V[a\0\xEFa\x02\x95V[a\0\xEFa\x02\xE2V[a\0\xEFa\x03\"V[a\0\xEFa\x03KV[a\0\xEFa\x03\x87V[a\0\xEFa\x03\xD7V[a\0\xEFa\x04,V[a\x01A_T\x81V[`@Q\x90\x81R` \x01`@Q\x80\x91\x03\x90\xF3[a\0\xEFa\x04_V[a\0\xEFa\x04\xBCV[a\0\xEFa\x04\xEEV[_Ta\x01x\x90`\x02a\x05\x17V[_Ta\x01\x85\x90`\x01a\x05\x17V[_T\x7F\xF5\x7FC>\xB9I<\xF4\xD9\xCBWc\xC1\"!\xD9\xB0\x95\x80FD\xD4\xEE\0jx\xC7 v\xCF\xF9Ga\x01\xB3\x82`\x03a\x05\x17V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xA4a\x01\xCDa\x04\xEEV[V[_T\x7F\xEFL\x88\x194\x98\xDF#\x7F\x03\x90U\xD1!*\xC2\xA3\xB9>\xD8\xAE\xA8\x8C\x81C\x12\xE5\x0Fj2Y-a\x01\xFD\x82`\x01a\x05\x17V[_Ta\x02\n\x90`\x02a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01[`@Q\x80\x91\x03\x90\xA2a\x01\xCDa\x04\xEEV[_Ta\x028\x90`\x02a\x05\x17V[_Ta\x02E\x90`\x01a\x05\x17V[_T\x7F\xF0=)u?\xBDZ\xC2\t\xBA\xB8\x8A\x99\xB3\x96\xBC\xC2\\>rS\r\x02\xC8\x1A\xEAM2J\xB3\xD7Ba\x02s\x82`\x03a\x05\x17V[_Ta\x02\x80\x90`\x04a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x01\xBDV[_Ta\x02\xA2\x90`\x02a\x05\x17V[_Ta\x02\xAF\x90`\x01a\x05\x17V[_\x80T`@Q\x90\x91\x7F\x1D\x18\xDE,\xD8y\x8A\x1C)\xB9%Y0\xC8\x07\xEBl\x84\xAE\n\xCB\"\x19\xAC\xBB\x11\xE0\xF6\\\xF8\x13\xE9\x91\xA4a\x01\xCDa\x04\xEEV[_Ta\x02\xEF\x90`\x01a\x05\x17V[_\x80T`@Q\x90\x91\x7F\xA6\xBA\xF1M\x8F\x11\xD7\xA4Ip\x89\xBB?\xCA\n\xDF\xC3H7\xCF\xB1\xF4\xAA7\x064\xD3n\xF00[F\x91\xA3a\x01\xCDa\x04\xEEV[`@Q~\xF7\xC7O\x053\xAA\x15\xE5\xAC|\xAF\xA9\xF9&\x1D\x14\xDA\x1Ex\x83\r\xEB\xA7\x11\x0F\xBCy\0\x1E\xD1^\x90_\x90\xA1V[_T\x7F\x16\x87\x18\xC0\xB1\xEBk\xFD{\x0E\xDE\xCE\xA5\xC6\xFCe\x02sz\xD7:L\x9FR\xFF\xA7\xE5S\xC8\xEB\x9FSa\x03y\x82`\x01a\x05\x17V[`@Q\x90\x81R` \x01a\x02\x1BV[_T\x7F/\xA6\x15\x17\xDD\xF9\xDC\x7F/=\\\xA7$\x14\xA0\x1C\x83M\x9C[\xB7\xC36\xC9wB<\x85\tK\xBAa\x90a\x03\xB6\x81`\x01a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01[`@Q\x80\x91\x03\x90\xA1a\x01\xCDa\x04\xEEV[_Ta\x03\xE4\x90`\x01a\x05\x17V[_T\x7F;\xB2\xD63x\x82\xFA\xA5Rl\xF8\x06\xC9v9\x04\xA9\x0F3cY\r\xD48i\x13\xE3\xFC\xD8\xA2\xE1\xD1a\x04\x12\x82`\x02a\x05\x17V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xA3a\x01\xCDa\x04\xEEV[_\x80T`@Q\x90\x91\x7F\xC2\x80\x9A\x1A/\xB9]\x84\xCF\xDCH\x8C\xDB2\n\x14L\x15\x8F\x8DD\x83l\x9C-K\xAD\xBA\x08+\xFD\xFA\x91\xA2a\x01\xCDa\x04\xEEV[_Ta\x04l\x90`\x01a\x05\x17V[_T\x7FK\x92\"\x9A\xBE J0\xD7\xB0\x88\xD8\x11\x02\x91v\t4\xD6[<\x96\x06\x80\xAD\x94\xE0_R\xA8\x86\x05a\x04\x9A\x82`\x02a\x05\x17V[_Ta\x04\xA7\x90`\x03a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x04\x1CV[\x7F\x04\xF7\xFB(\x9EQ\xEA\x99\x96\xEC\x98\xE6/\xF4\xB6Q\xBE\xCF\xA6\xE5?;\x85\x0B\xE2\t\xB6\x97A\xC6o$_T`@Qa\x03\xC7\x91\x81R` \x01\x90V[_\x80T\x90\x80a\x04\xFC\x83a\x050V[\x91\x90PUPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x01\x80\x82\x11\x15a\x05*Wa\x05*a\x05\x03V[\x92\x91PPV[_`\x01\x82\x01a\x05AWa\x05Aa\x05\x03V[P`\x01\x01\x90V\xFE\xA2dipfsX\"\x12 \xB4\xCC-\xF5\xEE\xD0oS\x8A1\x15~\xDF\xAE\xEE\xE5\x91\xA5q\x9D5\xFBG\xF3\xB6\xCE]1\xC1\xFF\xE2\xF9dsolcC\0\x08\x18\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b50600436106100e3575f3560e01c806346d6a7b5116100885780638381f58a116100635780638381f58a14610139578063b1e057a914610153578063c02420001461015b578063d09de08a14610163575f80fd5b806346d6a7b51461012157806363eb70f014610129578063729d452014610131575f80fd5b806331c1c63b116100c357806331c1c63b14610101578063338b538a146101095780634282ed58146101115780634369f72814610119575f80fd5b80623c7e56146100e7578062d83b55146100f15780632dc34764146100f9575b5f80fd5b6100ef61016b565b005b6100ef6101cf565b6100ef61022b565b6100ef610295565b6100ef6102e2565b6100ef610322565b6100ef61034b565b6100ef610387565b6100ef6103d7565b6100ef61042c565b6101415f5481565b60405190815260200160405180910390f35b6100ef61045f565b6100ef6104bc565b6100ef6104ee565b5f54610178906002610517565b5f54610185906001610517565b5f547ff57f433eb9493cf4d9cb5763c12221d9b095804644d4ee006a78c72076cff9476101b3826003610517565b6040519081526020015b60405180910390a46101cd6104ee565b565b5f547fef4c88193498df237f039055d1212ac2a3b93ed8aea88c814312e50f6a32592d6101fd826001610517565b5f5461020a906002610517565b604080519283526020830191909152015b60405180910390a26101cd6104ee565b5f54610238906002610517565b5f54610245906001610517565b5f547ff03d29753fbd5ac209bab88a99b396bcc25c3e72530d02c81aea4d324ab3d742610273826003610517565b5f54610280906004610517565b604080519283526020830191909152016101bd565b5f546102a2906002610517565b5f546102af906001610517565b5f805460405190917f1d18de2cd8798a1c29b9255930c807eb6c84ae0acb2219acbb11e0f65cf813e991a46101cd6104ee565b5f546102ef906001610517565b5f805460405190917fa6baf14d8f11d7a4497089bb3fca0adfc34837cfb1f4aa370634d36ef0305b4691a36101cd6104ee565b6040517ef7c74f0533aa15e5ac7cafa9f9261d14da1e78830deba7110fbc79001ed15e905f90a1565b5f547f168718c0b1eb6bfd7b0edecea5c6fc6502737ad73a4c9f52ffa7e553c8eb9f53610379826001610517565b60405190815260200161021b565b5f547f2fa61517ddf9dc7f2f3d5ca72414a01c834d9c5bb7c336c977423c85094bba61906103b6816001610517565b604080519283526020830191909152015b60405180910390a16101cd6104ee565b5f546103e4906001610517565b5f547f3bb2d6337882faa5526cf806c9763904a90f3363590dd4386913e3fcd8a2e1d1610412826002610517565b6040519081526020015b60405180910390a36101cd6104ee565b5f805460405190917fc2809a1a2fb95d84cfdc488cdb320a144c158f8d44836c9c2d4badba082bfdfa91a26101cd6104ee565b5f5461046c906001610517565b5f547f4b92229abe204a30d7b088d8110291760934d65b3c960680ad94e05f52a8860561049a826002610517565b5f546104a7906003610517565b6040805192835260208301919091520161041c565b7f04f7fb289e51ea9996ec98e62ff4b651becfa6e53f3b850be209b69741c66f245f546040516103c791815260200190565b5f805490806104fc83610530565b9190505550565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561052a5761052a610503565b92915050565b5f6001820161054157610541610503565b506001019056fea2646970667358221220b4cc2df5eed06f538a31157edfaeeee591a5719d35fb47f3b6ce5d31c1ffe2f964736f6c63430008180033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\xE3W_5`\xE0\x1C\x80cF\xD6\xA7\xB5\x11a\0\x88W\x80c\x83\x81\xF5\x8A\x11a\0cW\x80c\x83\x81\xF5\x8A\x14a\x019W\x80c\xB1\xE0W\xA9\x14a\x01SW\x80c\xC0$ \0\x14a\x01[W\x80c\xD0\x9D\xE0\x8A\x14a\x01cW_\x80\xFD[\x80cF\xD6\xA7\xB5\x14a\x01!W\x80cc\xEBp\xF0\x14a\x01)W\x80cr\x9DE \x14a\x011W_\x80\xFD[\x80c1\xC1\xC6;\x11a\0\xC3W\x80c1\xC1\xC6;\x14a\x01\x01W\x80c3\x8BS\x8A\x14a\x01\tW\x80cB\x82\xEDX\x14a\x01\x11W\x80cCi\xF7(\x14a\x01\x19W_\x80\xFD[\x80b<~V\x14a\0\xE7W\x80b\xD8;U\x14a\0\xF1W\x80c-\xC3Gd\x14a\0\xF9W[_\x80\xFD[a\0\xEFa\x01kV[\0[a\0\xEFa\x01\xCFV[a\0\xEFa\x02+V[a\0\xEFa\x02\x95V[a\0\xEFa\x02\xE2V[a\0\xEFa\x03\"V[a\0\xEFa\x03KV[a\0\xEFa\x03\x87V[a\0\xEFa\x03\xD7V[a\0\xEFa\x04,V[a\x01A_T\x81V[`@Q\x90\x81R` \x01`@Q\x80\x91\x03\x90\xF3[a\0\xEFa\x04_V[a\0\xEFa\x04\xBCV[a\0\xEFa\x04\xEEV[_Ta\x01x\x90`\x02a\x05\x17V[_Ta\x01\x85\x90`\x01a\x05\x17V[_T\x7F\xF5\x7FC>\xB9I<\xF4\xD9\xCBWc\xC1\"!\xD9\xB0\x95\x80FD\xD4\xEE\0jx\xC7 v\xCF\xF9Ga\x01\xB3\x82`\x03a\x05\x17V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xA4a\x01\xCDa\x04\xEEV[V[_T\x7F\xEFL\x88\x194\x98\xDF#\x7F\x03\x90U\xD1!*\xC2\xA3\xB9>\xD8\xAE\xA8\x8C\x81C\x12\xE5\x0Fj2Y-a\x01\xFD\x82`\x01a\x05\x17V[_Ta\x02\n\x90`\x02a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01[`@Q\x80\x91\x03\x90\xA2a\x01\xCDa\x04\xEEV[_Ta\x028\x90`\x02a\x05\x17V[_Ta\x02E\x90`\x01a\x05\x17V[_T\x7F\xF0=)u?\xBDZ\xC2\t\xBA\xB8\x8A\x99\xB3\x96\xBC\xC2\\>rS\r\x02\xC8\x1A\xEAM2J\xB3\xD7Ba\x02s\x82`\x03a\x05\x17V[_Ta\x02\x80\x90`\x04a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x01\xBDV[_Ta\x02\xA2\x90`\x02a\x05\x17V[_Ta\x02\xAF\x90`\x01a\x05\x17V[_\x80T`@Q\x90\x91\x7F\x1D\x18\xDE,\xD8y\x8A\x1C)\xB9%Y0\xC8\x07\xEBl\x84\xAE\n\xCB\"\x19\xAC\xBB\x11\xE0\xF6\\\xF8\x13\xE9\x91\xA4a\x01\xCDa\x04\xEEV[_Ta\x02\xEF\x90`\x01a\x05\x17V[_\x80T`@Q\x90\x91\x7F\xA6\xBA\xF1M\x8F\x11\xD7\xA4Ip\x89\xBB?\xCA\n\xDF\xC3H7\xCF\xB1\xF4\xAA7\x064\xD3n\xF00[F\x91\xA3a\x01\xCDa\x04\xEEV[`@Q~\xF7\xC7O\x053\xAA\x15\xE5\xAC|\xAF\xA9\xF9&\x1D\x14\xDA\x1Ex\x83\r\xEB\xA7\x11\x0F\xBCy\0\x1E\xD1^\x90_\x90\xA1V[_T\x7F\x16\x87\x18\xC0\xB1\xEBk\xFD{\x0E\xDE\xCE\xA5\xC6\xFCe\x02sz\xD7:L\x9FR\xFF\xA7\xE5S\xC8\xEB\x9FSa\x03y\x82`\x01a\x05\x17V[`@Q\x90\x81R` \x01a\x02\x1BV[_T\x7F/\xA6\x15\x17\xDD\xF9\xDC\x7F/=\\\xA7$\x14\xA0\x1C\x83M\x9C[\xB7\xC36\xC9wB<\x85\tK\xBAa\x90a\x03\xB6\x81`\x01a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01[`@Q\x80\x91\x03\x90\xA1a\x01\xCDa\x04\xEEV[_Ta\x03\xE4\x90`\x01a\x05\x17V[_T\x7F;\xB2\xD63x\x82\xFA\xA5Rl\xF8\x06\xC9v9\x04\xA9\x0F3cY\r\xD48i\x13\xE3\xFC\xD8\xA2\xE1\xD1a\x04\x12\x82`\x02a\x05\x17V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xA3a\x01\xCDa\x04\xEEV[_\x80T`@Q\x90\x91\x7F\xC2\x80\x9A\x1A/\xB9]\x84\xCF\xDCH\x8C\xDB2\n\x14L\x15\x8F\x8DD\x83l\x9C-K\xAD\xBA\x08+\xFD\xFA\x91\xA2a\x01\xCDa\x04\xEEV[_Ta\x04l\x90`\x01a\x05\x17V[_T\x7FK\x92\"\x9A\xBE J0\xD7\xB0\x88\xD8\x11\x02\x91v\t4\xD6[<\x96\x06\x80\xAD\x94\xE0_R\xA8\x86\x05a\x04\x9A\x82`\x02a\x05\x17V[_Ta\x04\xA7\x90`\x03a\x05\x17V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x04\x1CV[\x7F\x04\xF7\xFB(\x9EQ\xEA\x99\x96\xEC\x98\xE6/\xF4\xB6Q\xBE\xCF\xA6\xE5?;\x85\x0B\xE2\t\xB6\x97A\xC6o$_T`@Qa\x03\xC7\x91\x81R` \x01\x90V[_\x80T\x90\x80a\x04\xFC\x83a\x050V[\x91\x90PUPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x01\x80\x82\x11\x15a\x05*Wa\x05*a\x05\x03V[\x92\x91PPV[_`\x01\x82\x01a\x05AWa\x05Aa\x05\x03V[P`\x01\x01\x90V\xFE\xA2dipfsX\"\x12 \xB4\xCC-\xF5\xEE\xD0oS\x8A1\x15~\xDF\xAE\xEE\xE5\x91\xA5q\x9D5\xFBG\xF3\xB6\xCE]1\xC1\xFF\xE2\xF9dsolcC\0\x08\x18\x003",
    );
    /**Event with signature `noIOneD(uint256)` and selector `0x04f7fb289e51ea9996ec98e62ff4b651becfa6e53f3b850be209b69741c66f24`.
    ```solidity
    event noIOneD(uint256 num);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct noIOneD {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for noIOneD {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "noIOneD(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    4u8, 247u8, 251u8, 40u8, 158u8, 81u8, 234u8, 153u8, 150u8, 236u8, 152u8, 230u8,
                    47u8, 244u8, 182u8, 81u8, 190u8, 207u8, 166u8, 229u8, 63u8, 59u8, 133u8, 11u8,
                    226u8, 9u8, 182u8, 151u8, 65u8, 198u8, 111u8, 36u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { num: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.num,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for noIOneD {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&noIOneD> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &noIOneD) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `noITwoD(uint256,uint256)` and selector `0x2fa61517ddf9dc7f2f3d5ca72414a01c834d9c5bb7c336c977423c85094bba61`.
    ```solidity
    event noITwoD(uint256 num, uint256 numTwo);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct noITwoD {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for noITwoD {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "noITwoD(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    47u8, 166u8, 21u8, 23u8, 221u8, 249u8, 220u8, 127u8, 47u8, 61u8, 92u8, 167u8,
                    36u8, 20u8, 160u8, 28u8, 131u8, 77u8, 156u8, 91u8, 183u8, 195u8, 54u8, 201u8,
                    119u8, 66u8, 60u8, 133u8, 9u8, 75u8, 186u8, 97u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: data.0,
                    numTwo: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.num,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numTwo,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for noITwoD {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&noITwoD> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &noITwoD) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `noIndexed()` and selector `0x00f7c74f0533aa15e5ac7cafa9f9261d14da1e78830deba7110fbc79001ed15e`.
    ```solidity
    event noIndexed();
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct noIndexed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for noIndexed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "noIndexed()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    0u8, 247u8, 199u8, 79u8, 5u8, 51u8, 170u8, 21u8, 229u8, 172u8, 124u8, 175u8,
                    169u8, 249u8, 38u8, 29u8, 20u8, 218u8, 30u8, 120u8, 131u8, 13u8, 235u8, 167u8,
                    17u8, 15u8, 188u8, 121u8, 0u8, 30u8, 209u8, 94u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for noIndexed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&noIndexed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &noIndexed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `oneData(uint256,uint256,uint256,uint256)` and selector `0xf57f433eb9493cf4d9cb5763c12221d9b095804644d4ee006a78c72076cff947`.
    ```solidity
    event oneData(uint256 indexed num, uint256 indexed numTwo, uint256 indexed numThree, uint256 numFour);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct oneData {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numThree: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numFour: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for oneData {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "oneData(uint256,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    245u8, 127u8, 67u8, 62u8, 185u8, 73u8, 60u8, 244u8, 217u8, 203u8, 87u8, 99u8,
                    193u8, 34u8, 33u8, 217u8, 176u8, 149u8, 128u8, 70u8, 68u8, 212u8, 238u8, 0u8,
                    106u8, 120u8, 199u8, 32u8, 118u8, 207u8, 249u8, 71u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: topics.2,
                    numThree: topics.3,
                    numFour: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numFour,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.num.clone(),
                    self.numTwo.clone(),
                    self.numThree.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numTwo);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numThree);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for oneData {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&oneData> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &oneData) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `oneIOneD(uint256,uint256)` and selector `0x168718c0b1eb6bfd7b0edecea5c6fc6502737ad73a4c9f52ffa7e553c8eb9f53`.
    ```solidity
    event oneIOneD(uint256 indexed num, uint256 numTwo);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct oneIOneD {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for oneIOneD {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "oneIOneD(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    22u8, 135u8, 24u8, 192u8, 177u8, 235u8, 107u8, 253u8, 123u8, 14u8, 222u8,
                    206u8, 165u8, 198u8, 252u8, 101u8, 2u8, 115u8, 122u8, 215u8, 58u8, 76u8, 159u8,
                    82u8, 255u8, 167u8, 229u8, 83u8, 200u8, 235u8, 159u8, 83u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numTwo,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.num.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for oneIOneD {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&oneIOneD> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &oneIOneD) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `oneITwoD(uint256,uint256,uint256)` and selector `0xef4c88193498df237f039055d1212ac2a3b93ed8aea88c814312e50f6a32592d`.
    ```solidity
    event oneITwoD(uint256 indexed num, uint256 numTwo, uint256 numThree);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct oneITwoD {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numThree: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for oneITwoD {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "oneITwoD(uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    239u8, 76u8, 136u8, 25u8, 52u8, 152u8, 223u8, 35u8, 127u8, 3u8, 144u8, 85u8,
                    209u8, 33u8, 42u8, 194u8, 163u8, 185u8, 62u8, 216u8, 174u8, 168u8, 140u8,
                    129u8, 67u8, 18u8, 229u8, 15u8, 106u8, 50u8, 89u8, 45u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: data.0,
                    numThree: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numTwo,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numThree,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.num.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for oneITwoD {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&oneITwoD> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &oneITwoD) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `oneIndexed(uint256)` and selector `0xc2809a1a2fb95d84cfdc488cdb320a144c158f8d44836c9c2d4badba082bfdfa`.
    ```solidity
    event oneIndexed(uint256 indexed num);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct oneIndexed {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for oneIndexed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "oneIndexed(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    194u8, 128u8, 154u8, 26u8, 47u8, 185u8, 93u8, 132u8, 207u8, 220u8, 72u8, 140u8,
                    219u8, 50u8, 10u8, 20u8, 76u8, 21u8, 143u8, 141u8, 68u8, 131u8, 108u8, 156u8,
                    45u8, 75u8, 173u8, 186u8, 8u8, 43u8, 253u8, 250u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { num: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.num.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for oneIndexed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&oneIndexed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &oneIndexed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `threeIndexed(uint256,uint256,uint256)` and selector `0x1d18de2cd8798a1c29b9255930c807eb6c84ae0acb2219acbb11e0f65cf813e9`.
    ```solidity
    event threeIndexed(uint256 indexed num, uint256 indexed numTwo, uint256 indexed numThree);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct threeIndexed {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numThree: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for threeIndexed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "threeIndexed(uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    29u8, 24u8, 222u8, 44u8, 216u8, 121u8, 138u8, 28u8, 41u8, 185u8, 37u8, 89u8,
                    48u8, 200u8, 7u8, 235u8, 108u8, 132u8, 174u8, 10u8, 203u8, 34u8, 25u8, 172u8,
                    187u8, 17u8, 224u8, 246u8, 92u8, 248u8, 19u8, 233u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: topics.2,
                    numThree: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.num.clone(),
                    self.numTwo.clone(),
                    self.numThree.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numTwo);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numThree);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for threeIndexed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&threeIndexed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &threeIndexed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `twoData(uint256,uint256,uint256,uint256,uint256)` and selector `0xf03d29753fbd5ac209bab88a99b396bcc25c3e72530d02c81aea4d324ab3d742`.
    ```solidity
    event twoData(uint256 indexed num, uint256 indexed numTwo, uint256 indexed numThree, uint256 numFour, uint256 numFive);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct twoData {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numThree: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numFour: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numFive: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for twoData {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "twoData(uint256,uint256,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    240u8, 61u8, 41u8, 117u8, 63u8, 189u8, 90u8, 194u8, 9u8, 186u8, 184u8, 138u8,
                    153u8, 179u8, 150u8, 188u8, 194u8, 92u8, 62u8, 114u8, 83u8, 13u8, 2u8, 200u8,
                    26u8, 234u8, 77u8, 50u8, 74u8, 179u8, 215u8, 66u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: topics.2,
                    numThree: topics.3,
                    numFour: data.0,
                    numFive: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numFour,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numFive,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.num.clone(),
                    self.numTwo.clone(),
                    self.numThree.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numTwo);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numThree);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for twoData {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&twoData> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &twoData) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `twoIOneD(uint256,uint256,uint256)` and selector `0x3bb2d6337882faa5526cf806c9763904a90f3363590dd4386913e3fcd8a2e1d1`.
    ```solidity
    event twoIOneD(uint256 indexed num, uint256 indexed numTwo, uint256 numThree);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct twoIOneD {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numThree: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for twoIOneD {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "twoIOneD(uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    59u8, 178u8, 214u8, 51u8, 120u8, 130u8, 250u8, 165u8, 82u8, 108u8, 248u8, 6u8,
                    201u8, 118u8, 57u8, 4u8, 169u8, 15u8, 51u8, 99u8, 89u8, 13u8, 212u8, 56u8,
                    105u8, 19u8, 227u8, 252u8, 216u8, 162u8, 225u8, 209u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: topics.2,
                    numThree: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numThree,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.num.clone(),
                    self.numTwo.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numTwo);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for twoIOneD {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&twoIOneD> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &twoIOneD) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `twoITwoD(uint256,uint256,uint256,uint256)` and selector `0x4b92229abe204a30d7b088d8110291760934d65b3c960680ad94e05f52a88605`.
    ```solidity
    event twoITwoD(uint256 indexed num, uint256 indexed numTwo, uint256 numThree, uint256 numFour);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct twoITwoD {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numThree: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numFour: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for twoITwoD {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "twoITwoD(uint256,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    75u8, 146u8, 34u8, 154u8, 190u8, 32u8, 74u8, 48u8, 215u8, 176u8, 136u8, 216u8,
                    17u8, 2u8, 145u8, 118u8, 9u8, 52u8, 214u8, 91u8, 60u8, 150u8, 6u8, 128u8,
                    173u8, 148u8, 224u8, 95u8, 82u8, 168u8, 134u8, 5u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: topics.2,
                    numThree: data.0,
                    numFour: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numThree,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numFour,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.num.clone(),
                    self.numTwo.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numTwo);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for twoITwoD {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&twoITwoD> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &twoITwoD) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `twoIndexed(uint256,uint256)` and selector `0xa6baf14d8f11d7a4497089bb3fca0adfc34837cfb1f4aa370634d36ef0305b46`.
    ```solidity
    event twoIndexed(uint256 indexed num, uint256 indexed numTwo);
    ```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct twoIndexed {
        #[allow(missing_docs)]
        pub num: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numTwo: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for twoIndexed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "twoIndexed(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    166u8, 186u8, 241u8, 77u8, 143u8, 17u8, 215u8, 164u8, 73u8, 112u8, 137u8,
                    187u8, 63u8, 202u8, 10u8, 223u8, 195u8, 72u8, 55u8, 207u8, 177u8, 244u8, 170u8,
                    55u8, 6u8, 52u8, 211u8, 110u8, 240u8, 48u8, 91u8, 70u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    num: topics.1,
                    numTwo: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.num.clone(),
                    self.numTwo.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.num);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.numTwo);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for twoIndexed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&twoIndexed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &twoIndexed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `increment()` and selector `0xd09de08a`.
    ```solidity
    function increment() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementCall {}
    ///Container type for the return parameters of the [`increment()`](incrementCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementCall> for UnderlyingRustTuple<'_> {
                fn from(value: incrementCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementReturn> for UnderlyingRustTuple<'_> {
                fn from(value: incrementReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for incrementCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = incrementReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "increment()";
            const SELECTOR: [u8; 4] = [208u8, 157u8, 224u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `number()` and selector `0x8381f58a`.
    ```solidity
    function number() external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numberCall {}
    ///Container type for the return parameters of the [`number()`](numberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numberReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numberCall> for UnderlyingRustTuple<'_> {
                fn from(value: numberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: numberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = numberReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "number()";
            const SELECTOR: [u8; 4] = [131u8, 129u8, 245u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testNoIOneD()` and selector `0xc0242000`.
    ```solidity
    function testNoIOneD() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testNoIOneDCall {}
    ///Container type for the return parameters of the [`testNoIOneD()`](testNoIOneDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testNoIOneDReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testNoIOneDCall> for UnderlyingRustTuple<'_> {
                fn from(value: testNoIOneDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testNoIOneDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testNoIOneDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testNoIOneDReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testNoIOneDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testNoIOneDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testNoIOneDReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testNoIOneD()";
            const SELECTOR: [u8; 4] = [192u8, 36u8, 32u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testNoITwoD()` and selector `0x46d6a7b5`.
    ```solidity
    function testNoITwoD() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testNoITwoDCall {}
    ///Container type for the return parameters of the [`testNoITwoD()`](testNoITwoDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testNoITwoDReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testNoITwoDCall> for UnderlyingRustTuple<'_> {
                fn from(value: testNoITwoDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testNoITwoDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testNoITwoDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testNoITwoDReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testNoITwoDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testNoITwoDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testNoITwoDReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testNoITwoD()";
            const SELECTOR: [u8; 4] = [70u8, 214u8, 167u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testNoIndexed()` and selector `0x4282ed58`.
    ```solidity
    function testNoIndexed() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testNoIndexedCall {}
    ///Container type for the return parameters of the [`testNoIndexed()`](testNoIndexedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testNoIndexedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testNoIndexedCall> for UnderlyingRustTuple<'_> {
                fn from(value: testNoIndexedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testNoIndexedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testNoIndexedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testNoIndexedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testNoIndexedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testNoIndexedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testNoIndexedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testNoIndexed()";
            const SELECTOR: [u8; 4] = [66u8, 130u8, 237u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testOneData()` and selector `0x003c7e56`.
    ```solidity
    function testOneData() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneDataCall {}
    ///Container type for the return parameters of the [`testOneData()`](testOneDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: testOneDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testOneDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testOneDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testOneDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testOneData()";
            const SELECTOR: [u8; 4] = [0u8, 60u8, 126u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testOneIOneD()` and selector `0x4369f728`.
    ```solidity
    function testOneIOneD() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneIOneDCall {}
    ///Container type for the return parameters of the [`testOneIOneD()`](testOneIOneDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneIOneDReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneIOneDCall> for UnderlyingRustTuple<'_> {
                fn from(value: testOneIOneDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneIOneDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneIOneDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testOneIOneDReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneIOneDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testOneIOneDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testOneIOneDReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testOneIOneD()";
            const SELECTOR: [u8; 4] = [67u8, 105u8, 247u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testOneITwoD()` and selector `0x00d83b55`.
    ```solidity
    function testOneITwoD() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneITwoDCall {}
    ///Container type for the return parameters of the [`testOneITwoD()`](testOneITwoDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneITwoDReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneITwoDCall> for UnderlyingRustTuple<'_> {
                fn from(value: testOneITwoDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneITwoDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneITwoDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testOneITwoDReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneITwoDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testOneITwoDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testOneITwoDReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testOneITwoD()";
            const SELECTOR: [u8; 4] = [0u8, 216u8, 59u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testOneIndexed()` and selector `0x729d4520`.
    ```solidity
    function testOneIndexed() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneIndexedCall {}
    ///Container type for the return parameters of the [`testOneIndexed()`](testOneIndexedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testOneIndexedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneIndexedCall> for UnderlyingRustTuple<'_> {
                fn from(value: testOneIndexedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneIndexedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testOneIndexedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testOneIndexedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testOneIndexedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testOneIndexedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testOneIndexedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testOneIndexed()";
            const SELECTOR: [u8; 4] = [114u8, 157u8, 69u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testThreeIndexed()` and selector `0x31c1c63b`.
    ```solidity
    function testThreeIndexed() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testThreeIndexedCall {}
    ///Container type for the return parameters of the [`testThreeIndexed()`](testThreeIndexedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testThreeIndexedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testThreeIndexedCall> for UnderlyingRustTuple<'_> {
                fn from(value: testThreeIndexedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testThreeIndexedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testThreeIndexedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testThreeIndexedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testThreeIndexedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testThreeIndexedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testThreeIndexedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testThreeIndexed()";
            const SELECTOR: [u8; 4] = [49u8, 193u8, 198u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testTwoData()` and selector `0x2dc34764`.
    ```solidity
    function testTwoData() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoDataCall {}
    ///Container type for the return parameters of the [`testTwoData()`](testTwoDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testTwoDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testTwoDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testTwoData()";
            const SELECTOR: [u8; 4] = [45u8, 195u8, 71u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testTwoIOneD()` and selector `0x63eb70f0`.
    ```solidity
    function testTwoIOneD() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoIOneDCall {}
    ///Container type for the return parameters of the [`testTwoIOneD()`](testTwoIOneDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoIOneDReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoIOneDCall> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoIOneDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoIOneDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoIOneDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoIOneDReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoIOneDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testTwoIOneDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testTwoIOneDReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testTwoIOneD()";
            const SELECTOR: [u8; 4] = [99u8, 235u8, 112u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testTwoITwoD()` and selector `0xb1e057a9`.
    ```solidity
    function testTwoITwoD() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoITwoDCall {}
    ///Container type for the return parameters of the [`testTwoITwoD()`](testTwoITwoDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoITwoDReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoITwoDCall> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoITwoDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoITwoDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoITwoDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoITwoDReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoITwoDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testTwoITwoDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testTwoITwoDReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testTwoITwoD()";
            const SELECTOR: [u8; 4] = [177u8, 224u8, 87u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `testTwoIndexed()` and selector `0x338b538a`.
    ```solidity
    function testTwoIndexed() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoIndexedCall {}
    ///Container type for the return parameters of the [`testTwoIndexed()`](testTwoIndexedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct testTwoIndexedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoIndexedCall> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoIndexedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoIndexedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<testTwoIndexedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: testTwoIndexedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for testTwoIndexedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for testTwoIndexedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = testTwoIndexedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "testTwoIndexed()";
            const SELECTOR: [u8; 4] = [51u8, 139u8, 83u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    ///Container for all the [`EventEmitter`](self) function calls.
    pub enum EventEmitterCalls {
        increment(incrementCall),
        number(numberCall),
        testNoIOneD(testNoIOneDCall),
        testNoITwoD(testNoITwoDCall),
        testNoIndexed(testNoIndexedCall),
        testOneData(testOneDataCall),
        testOneIOneD(testOneIOneDCall),
        testOneITwoD(testOneITwoDCall),
        testOneIndexed(testOneIndexedCall),
        testThreeIndexed(testThreeIndexedCall),
        testTwoData(testTwoDataCall),
        testTwoIOneD(testTwoIOneDCall),
        testTwoITwoD(testTwoITwoDCall),
        testTwoIndexed(testTwoIndexedCall),
    }
    #[automatically_derived]
    impl EventEmitterCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 60u8, 126u8, 86u8],
            [0u8, 216u8, 59u8, 85u8],
            [45u8, 195u8, 71u8, 100u8],
            [49u8, 193u8, 198u8, 59u8],
            [51u8, 139u8, 83u8, 138u8],
            [66u8, 130u8, 237u8, 88u8],
            [67u8, 105u8, 247u8, 40u8],
            [70u8, 214u8, 167u8, 181u8],
            [99u8, 235u8, 112u8, 240u8],
            [114u8, 157u8, 69u8, 32u8],
            [131u8, 129u8, 245u8, 138u8],
            [177u8, 224u8, 87u8, 169u8],
            [192u8, 36u8, 32u8, 0u8],
            [208u8, 157u8, 224u8, 138u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EventEmitterCalls {
        const NAME: &'static str = "EventEmitterCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 14usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::increment(_) => <incrementCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::number(_) => <numberCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testNoIOneD(_) => <testNoIOneDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testNoITwoD(_) => <testNoITwoDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testNoIndexed(_) => <testNoIndexedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testOneData(_) => <testOneDataCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testOneIOneD(_) => <testOneIOneDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testOneITwoD(_) => <testOneITwoDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testOneIndexed(_) => {
                    <testOneIndexedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::testThreeIndexed(_) => {
                    <testThreeIndexedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::testTwoData(_) => <testTwoDataCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testTwoIOneD(_) => <testTwoIOneDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testTwoITwoD(_) => <testTwoITwoDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::testTwoIndexed(_) => {
                    <testTwoIndexedCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<EventEmitterCalls>] = &[
                {
                    fn testOneData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testOneDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testOneData)
                    }
                    testOneData
                },
                {
                    fn testOneITwoD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testOneITwoDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testOneITwoD)
                    }
                    testOneITwoD
                },
                {
                    fn testTwoData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testTwoDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testTwoData)
                    }
                    testTwoData
                },
                {
                    fn testThreeIndexed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testThreeIndexedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testThreeIndexed)
                    }
                    testThreeIndexed
                },
                {
                    fn testTwoIndexed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testTwoIndexedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testTwoIndexed)
                    }
                    testTwoIndexed
                },
                {
                    fn testNoIndexed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testNoIndexedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testNoIndexed)
                    }
                    testNoIndexed
                },
                {
                    fn testOneIOneD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testOneIOneDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testOneIOneD)
                    }
                    testOneIOneD
                },
                {
                    fn testNoITwoD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testNoITwoDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testNoITwoD)
                    }
                    testNoITwoD
                },
                {
                    fn testTwoIOneD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testTwoIOneDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testTwoIOneD)
                    }
                    testTwoIOneD
                },
                {
                    fn testOneIndexed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testOneIndexedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testOneIndexed)
                    }
                    testOneIndexed
                },
                {
                    fn number(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <numberCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(EventEmitterCalls::number)
                    }
                    number
                },
                {
                    fn testTwoITwoD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testTwoITwoDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testTwoITwoD)
                    }
                    testTwoITwoD
                },
                {
                    fn testNoIOneD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <testNoIOneDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(EventEmitterCalls::testNoIOneD)
                    }
                    testNoIOneD
                },
                {
                    fn increment(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EventEmitterCalls> {
                        <incrementCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(EventEmitterCalls::increment)
                    }
                    increment
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::increment(inner) => {
                    <incrementCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::number(inner) => {
                    <numberCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testNoIOneD(inner) => {
                    <testNoIOneDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testNoITwoD(inner) => {
                    <testNoITwoDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testNoIndexed(inner) => {
                    <testNoIndexedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testOneData(inner) => {
                    <testOneDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testOneIOneD(inner) => {
                    <testOneIOneDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testOneITwoD(inner) => {
                    <testOneITwoDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testOneIndexed(inner) => {
                    <testOneIndexedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testThreeIndexed(inner) => {
                    <testThreeIndexedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testTwoData(inner) => {
                    <testTwoDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testTwoIOneD(inner) => {
                    <testTwoIOneDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testTwoITwoD(inner) => {
                    <testTwoITwoDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::testTwoIndexed(inner) => {
                    <testTwoIndexedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::increment(inner) => {
                    <incrementCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::number(inner) => {
                    <numberCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testNoIOneD(inner) => {
                    <testNoIOneDCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testNoITwoD(inner) => {
                    <testNoITwoDCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testNoIndexed(inner) => {
                    <testNoIndexedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testOneData(inner) => {
                    <testOneDataCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testOneIOneD(inner) => {
                    <testOneIOneDCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testOneITwoD(inner) => {
                    <testOneITwoDCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testOneIndexed(inner) => {
                    <testOneIndexedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testThreeIndexed(inner) => {
                    <testThreeIndexedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testTwoData(inner) => {
                    <testTwoDataCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testTwoIOneD(inner) => {
                    <testTwoIOneDCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testTwoITwoD(inner) => {
                    <testTwoITwoDCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::testTwoIndexed(inner) => {
                    <testTwoIndexedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`EventEmitter`](self) events.
    pub enum EventEmitterEvents {
        noIOneD(noIOneD),
        noITwoD(noITwoD),
        noIndexed(noIndexed),
        oneData(oneData),
        oneIOneD(oneIOneD),
        oneITwoD(oneITwoD),
        oneIndexed(oneIndexed),
        threeIndexed(threeIndexed),
        twoData(twoData),
        twoIOneD(twoIOneD),
        twoITwoD(twoITwoD),
        twoIndexed(twoIndexed),
    }
    #[automatically_derived]
    impl EventEmitterEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                0u8, 247u8, 199u8, 79u8, 5u8, 51u8, 170u8, 21u8, 229u8, 172u8, 124u8, 175u8, 169u8,
                249u8, 38u8, 29u8, 20u8, 218u8, 30u8, 120u8, 131u8, 13u8, 235u8, 167u8, 17u8, 15u8,
                188u8, 121u8, 0u8, 30u8, 209u8, 94u8,
            ],
            [
                4u8, 247u8, 251u8, 40u8, 158u8, 81u8, 234u8, 153u8, 150u8, 236u8, 152u8, 230u8,
                47u8, 244u8, 182u8, 81u8, 190u8, 207u8, 166u8, 229u8, 63u8, 59u8, 133u8, 11u8,
                226u8, 9u8, 182u8, 151u8, 65u8, 198u8, 111u8, 36u8,
            ],
            [
                22u8, 135u8, 24u8, 192u8, 177u8, 235u8, 107u8, 253u8, 123u8, 14u8, 222u8, 206u8,
                165u8, 198u8, 252u8, 101u8, 2u8, 115u8, 122u8, 215u8, 58u8, 76u8, 159u8, 82u8,
                255u8, 167u8, 229u8, 83u8, 200u8, 235u8, 159u8, 83u8,
            ],
            [
                29u8, 24u8, 222u8, 44u8, 216u8, 121u8, 138u8, 28u8, 41u8, 185u8, 37u8, 89u8, 48u8,
                200u8, 7u8, 235u8, 108u8, 132u8, 174u8, 10u8, 203u8, 34u8, 25u8, 172u8, 187u8,
                17u8, 224u8, 246u8, 92u8, 248u8, 19u8, 233u8,
            ],
            [
                47u8, 166u8, 21u8, 23u8, 221u8, 249u8, 220u8, 127u8, 47u8, 61u8, 92u8, 167u8, 36u8,
                20u8, 160u8, 28u8, 131u8, 77u8, 156u8, 91u8, 183u8, 195u8, 54u8, 201u8, 119u8,
                66u8, 60u8, 133u8, 9u8, 75u8, 186u8, 97u8,
            ],
            [
                59u8, 178u8, 214u8, 51u8, 120u8, 130u8, 250u8, 165u8, 82u8, 108u8, 248u8, 6u8,
                201u8, 118u8, 57u8, 4u8, 169u8, 15u8, 51u8, 99u8, 89u8, 13u8, 212u8, 56u8, 105u8,
                19u8, 227u8, 252u8, 216u8, 162u8, 225u8, 209u8,
            ],
            [
                75u8, 146u8, 34u8, 154u8, 190u8, 32u8, 74u8, 48u8, 215u8, 176u8, 136u8, 216u8,
                17u8, 2u8, 145u8, 118u8, 9u8, 52u8, 214u8, 91u8, 60u8, 150u8, 6u8, 128u8, 173u8,
                148u8, 224u8, 95u8, 82u8, 168u8, 134u8, 5u8,
            ],
            [
                166u8, 186u8, 241u8, 77u8, 143u8, 17u8, 215u8, 164u8, 73u8, 112u8, 137u8, 187u8,
                63u8, 202u8, 10u8, 223u8, 195u8, 72u8, 55u8, 207u8, 177u8, 244u8, 170u8, 55u8, 6u8,
                52u8, 211u8, 110u8, 240u8, 48u8, 91u8, 70u8,
            ],
            [
                194u8, 128u8, 154u8, 26u8, 47u8, 185u8, 93u8, 132u8, 207u8, 220u8, 72u8, 140u8,
                219u8, 50u8, 10u8, 20u8, 76u8, 21u8, 143u8, 141u8, 68u8, 131u8, 108u8, 156u8, 45u8,
                75u8, 173u8, 186u8, 8u8, 43u8, 253u8, 250u8,
            ],
            [
                239u8, 76u8, 136u8, 25u8, 52u8, 152u8, 223u8, 35u8, 127u8, 3u8, 144u8, 85u8, 209u8,
                33u8, 42u8, 194u8, 163u8, 185u8, 62u8, 216u8, 174u8, 168u8, 140u8, 129u8, 67u8,
                18u8, 229u8, 15u8, 106u8, 50u8, 89u8, 45u8,
            ],
            [
                240u8, 61u8, 41u8, 117u8, 63u8, 189u8, 90u8, 194u8, 9u8, 186u8, 184u8, 138u8,
                153u8, 179u8, 150u8, 188u8, 194u8, 92u8, 62u8, 114u8, 83u8, 13u8, 2u8, 200u8, 26u8,
                234u8, 77u8, 50u8, 74u8, 179u8, 215u8, 66u8,
            ],
            [
                245u8, 127u8, 67u8, 62u8, 185u8, 73u8, 60u8, 244u8, 217u8, 203u8, 87u8, 99u8,
                193u8, 34u8, 33u8, 217u8, 176u8, 149u8, 128u8, 70u8, 68u8, 212u8, 238u8, 0u8,
                106u8, 120u8, 199u8, 32u8, 118u8, 207u8, 249u8, 71u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for EventEmitterEvents {
        const NAME: &'static str = "EventEmitterEvents";
        const COUNT: usize = 12usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<noIOneD as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <noIOneD as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::noIOneD)
                }
                Some(<noITwoD as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <noITwoD as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::noITwoD)
                }
                Some(<noIndexed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <noIndexed as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::noIndexed)
                }
                Some(<oneData as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <oneData as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::oneData)
                }
                Some(<oneIOneD as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <oneIOneD as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::oneIOneD)
                }
                Some(<oneITwoD as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <oneITwoD as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::oneITwoD)
                }
                Some(<oneIndexed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <oneIndexed as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::oneIndexed)
                }
                Some(<threeIndexed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <threeIndexed as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::threeIndexed)
                }
                Some(<twoData as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <twoData as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::twoData)
                }
                Some(<twoIOneD as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <twoIOneD as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::twoIOneD)
                }
                Some(<twoITwoD as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <twoITwoD as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::twoITwoD)
                }
                Some(<twoIndexed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <twoIndexed as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::twoIndexed)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for EventEmitterEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::noIOneD(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::noITwoD(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::noIndexed(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::oneData(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::oneIOneD(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::oneITwoD(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::oneIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::threeIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::twoData(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::twoIOneD(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::twoITwoD(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::twoIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::noIOneD(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
                Self::noITwoD(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
                Self::noIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::oneData(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
                Self::oneIOneD(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::oneITwoD(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::oneIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::threeIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::twoData(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
                Self::twoIOneD(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::twoITwoD(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::twoIndexed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`EventEmitter`](self) contract instance.

    See the [wrapper's documentation](`EventEmitterInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> EventEmitterInstance<T, P, N> {
        EventEmitterInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

    Returns a new instance of the contract, if the deployment was successful.

    For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<EventEmitterInstance<T, P, N>>>
    {
        EventEmitterInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
    and constructor arguments, if any.

    This is a simple wrapper around creating a `RawCallBuilder` with the data set to
    the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        EventEmitterInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`EventEmitter`](self) instance.

    Contains type-safe methods for interacting with an on-chain instance of the
    [`EventEmitter`](self) contract located at a given `address`, using a given
    provider `P`.

    If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
    documentation on how to provide it), the `deploy` and `deploy_builder` methods can
    be used to deploy a new instance of the contract.

    See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct EventEmitterInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for EventEmitterInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("EventEmitterInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > EventEmitterInstance<T, P, N>
    {
        /**Creates a new wrapper around an on-chain [`EventEmitter`](self) contract instance.

        See the [wrapper's documentation](`EventEmitterInstance`) for more details.*/
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

        Returns a new instance of the contract, if the deployment was successful.

        For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(provider: P) -> alloy_contract::Result<EventEmitterInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
        and constructor arguments, if any.

        This is a simple wrapper around creating a `RawCallBuilder` with the data set to
        the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> EventEmitterInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> EventEmitterInstance<T, P, N> {
            EventEmitterInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > EventEmitterInstance<T, P, N>
    {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`increment`] function.
        pub fn increment(&self) -> alloy_contract::SolCallBuilder<T, &P, incrementCall, N> {
            self.call_builder(&incrementCall {})
        }
        ///Creates a new call builder for the [`number`] function.
        pub fn number(&self) -> alloy_contract::SolCallBuilder<T, &P, numberCall, N> {
            self.call_builder(&numberCall {})
        }
        ///Creates a new call builder for the [`testNoIOneD`] function.
        pub fn testNoIOneD(&self) -> alloy_contract::SolCallBuilder<T, &P, testNoIOneDCall, N> {
            self.call_builder(&testNoIOneDCall {})
        }
        ///Creates a new call builder for the [`testNoITwoD`] function.
        pub fn testNoITwoD(&self) -> alloy_contract::SolCallBuilder<T, &P, testNoITwoDCall, N> {
            self.call_builder(&testNoITwoDCall {})
        }
        ///Creates a new call builder for the [`testNoIndexed`] function.
        pub fn testNoIndexed(&self) -> alloy_contract::SolCallBuilder<T, &P, testNoIndexedCall, N> {
            self.call_builder(&testNoIndexedCall {})
        }
        ///Creates a new call builder for the [`testOneData`] function.
        pub fn testOneData(&self) -> alloy_contract::SolCallBuilder<T, &P, testOneDataCall, N> {
            self.call_builder(&testOneDataCall {})
        }
        ///Creates a new call builder for the [`testOneIOneD`] function.
        pub fn testOneIOneD(&self) -> alloy_contract::SolCallBuilder<T, &P, testOneIOneDCall, N> {
            self.call_builder(&testOneIOneDCall {})
        }
        ///Creates a new call builder for the [`testOneITwoD`] function.
        pub fn testOneITwoD(&self) -> alloy_contract::SolCallBuilder<T, &P, testOneITwoDCall, N> {
            self.call_builder(&testOneITwoDCall {})
        }
        ///Creates a new call builder for the [`testOneIndexed`] function.
        pub fn testOneIndexed(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, testOneIndexedCall, N> {
            self.call_builder(&testOneIndexedCall {})
        }
        ///Creates a new call builder for the [`testThreeIndexed`] function.
        pub fn testThreeIndexed(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, testThreeIndexedCall, N> {
            self.call_builder(&testThreeIndexedCall {})
        }
        ///Creates a new call builder for the [`testTwoData`] function.
        pub fn testTwoData(&self) -> alloy_contract::SolCallBuilder<T, &P, testTwoDataCall, N> {
            self.call_builder(&testTwoDataCall {})
        }
        ///Creates a new call builder for the [`testTwoIOneD`] function.
        pub fn testTwoIOneD(&self) -> alloy_contract::SolCallBuilder<T, &P, testTwoIOneDCall, N> {
            self.call_builder(&testTwoIOneDCall {})
        }
        ///Creates a new call builder for the [`testTwoITwoD`] function.
        pub fn testTwoITwoD(&self) -> alloy_contract::SolCallBuilder<T, &P, testTwoITwoDCall, N> {
            self.call_builder(&testTwoITwoDCall {})
        }
        ///Creates a new call builder for the [`testTwoIndexed`] function.
        pub fn testTwoIndexed(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, testTwoIndexedCall, N> {
            self.call_builder(&testTwoIndexedCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > EventEmitterInstance<T, P, N>
    {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`noIOneD`] event.
        pub fn noIOneD_filter(&self) -> alloy_contract::Event<T, &P, noIOneD, N> {
            self.event_filter::<noIOneD>()
        }
        ///Creates a new event filter for the [`noITwoD`] event.
        pub fn noITwoD_filter(&self) -> alloy_contract::Event<T, &P, noITwoD, N> {
            self.event_filter::<noITwoD>()
        }
        ///Creates a new event filter for the [`noIndexed`] event.
        pub fn noIndexed_filter(&self) -> alloy_contract::Event<T, &P, noIndexed, N> {
            self.event_filter::<noIndexed>()
        }
        ///Creates a new event filter for the [`oneData`] event.
        pub fn oneData_filter(&self) -> alloy_contract::Event<T, &P, oneData, N> {
            self.event_filter::<oneData>()
        }
        ///Creates a new event filter for the [`oneIOneD`] event.
        pub fn oneIOneD_filter(&self) -> alloy_contract::Event<T, &P, oneIOneD, N> {
            self.event_filter::<oneIOneD>()
        }
        ///Creates a new event filter for the [`oneITwoD`] event.
        pub fn oneITwoD_filter(&self) -> alloy_contract::Event<T, &P, oneITwoD, N> {
            self.event_filter::<oneITwoD>()
        }
        ///Creates a new event filter for the [`oneIndexed`] event.
        pub fn oneIndexed_filter(&self) -> alloy_contract::Event<T, &P, oneIndexed, N> {
            self.event_filter::<oneIndexed>()
        }
        ///Creates a new event filter for the [`threeIndexed`] event.
        pub fn threeIndexed_filter(&self) -> alloy_contract::Event<T, &P, threeIndexed, N> {
            self.event_filter::<threeIndexed>()
        }
        ///Creates a new event filter for the [`twoData`] event.
        pub fn twoData_filter(&self) -> alloy_contract::Event<T, &P, twoData, N> {
            self.event_filter::<twoData>()
        }
        ///Creates a new event filter for the [`twoIOneD`] event.
        pub fn twoIOneD_filter(&self) -> alloy_contract::Event<T, &P, twoIOneD, N> {
            self.event_filter::<twoIOneD>()
        }
        ///Creates a new event filter for the [`twoITwoD`] event.
        pub fn twoITwoD_filter(&self) -> alloy_contract::Event<T, &P, twoITwoD, N> {
            self.event_filter::<twoITwoD>()
        }
        ///Creates a new event filter for the [`twoIndexed`] event.
        pub fn twoIndexed_filter(&self) -> alloy_contract::Event<T, &P, twoIndexed, N> {
            self.event_filter::<twoIndexed>()
        }
    }
}
